<!DOCTYPE html><html lang="en" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="theme-color" media="(prefers-color-scheme: light)" content="#f7f7f7"><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1b1b1e"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="viewport" content="width=device-width, user-scalable=no initial-scale=1, shrink-to-fit=no, viewport-fit=cover" ><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="Redis 知识体系" /><meta property="og:locale" content="en" /><meta name="description" content="单机 QPS" /><meta property="og:description" content="单机 QPS" /><link rel="canonical" href="/posts/redis/" /><meta property="og:url" content="/posts/redis/" /><meta property="og:site_name" content="Blogs" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2023-07-06T19:24:40+08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Redis 知识体系" /><meta name="twitter:site" content="@CompetitiveLin" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2024-12-11T15:45:26+08:00","datePublished":"2023-07-06T19:24:40+08:00","description":"单机 QPS","headline":"Redis 知识体系","mainEntityOfPage":{"@type":"WebPage","@id":"/posts/redis/"},"url":"/posts/redis/"}</script><title>Redis 知识体系 | Blogs</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Blogs"><meta name="application-name" content="Blogs"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/tocbot@4.20.1/dist/tocbot.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener('change', () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.notify(); } /* flipMode() */ } /* ModeToggle */ const modeToggle = new ModeToggle(); </script><body data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" class="mx-auto"> <img src="/assets/img/avator.jpg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title"> <a href="/">Blogs</a></div><div class="site-subtitle font-italic">Recording everything in here.</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/CompetitiveLin" aria-label="github" target="_blank" rel="noopener noreferrer"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/CompetitiveLin" aria-label="twitter" target="_blank" rel="noopener noreferrer"> <i class="fab fa-twitter"></i> </a> <a href="javascript:location.href = 'mailto:' + ['zee_lin','foxmail.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper"><div id="topbar" class="container d-flex align-items-center justify-content-between h-100 pl-3 pr-3 pl-md-4 pr-md-4"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>Redis 知识体系</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper" class="d-flex justify-content-center"><div id="main" class="container pl-xl-4 pr-xl-4"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-9 pr-xl-4"><div class="post pl-1 pr-1 pl-md-2 pr-md-2"><h1 data-toc-skip>Redis 知识体系</h1><div class="post-meta text-muted"> <span> Posted <em class="" data-ts="1688642680" data-df="ll" data-toggle="tooltip" data-placement="bottom"> Jul 6, 2023 </em> </span> <span> Updated <em class="" data-ts="1733903126" data-df="ll" data-toggle="tooltip" data-placement="bottom"> Dec 11, 2024 </em> </span><div class="d-flex justify-content-between"> <span> By <em> <a href="https://github.com/CompetitiveLin">CompetitiveLin</a> </em> </span><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="5898 words"> <em>32 min</em> read</span></div></div></div><div class="post-content"><h1 id="单机-qps">单机 QPS</h1><p>单机 QPS 能力参考范围为 8 - 10 万。</p><h1 id="为什么-redis-这么快">为什么 Redis 这么快</h1><ol><li>用 C 语言编写的，执行效率高<li>基于内存的数据库，避免磁盘IO操作<li>采用高效的数据结构<li>合理的数据编码，同样的数据结构在不同数据量的情况下采用不同的编码方式<li>采用单线程，避免上下文切换<li>多路IO复用，一个线程处理多个大量Socket请求。<li>虚拟内存</ol><h1 id="虚拟内存">虚拟内存</h1><p>Redis 的数据并不是完全在内存中，当 Redis 的数据量大于物理内存容量时，会通过<strong>虚拟内存</strong>的手段，将不经常使用的数据（冷数据）存储到硬盘上，以释放物理内存空间。</p><p>在虚拟内存中，数据被分为多个页面，每个页面大小默认 32 字节。显然，虚拟内存可以节省内存，但也带来一定的性能损失。</p><h1 id="持久化">持久化</h1><h2 id="aof"><span class="mr-2">AOF</span><a href="#aof" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>采用<strong>写后日志</strong>的方式，先执行命令，再将操作日志以文本形式追加到文件中。</p><p>为什么采用写后日志？（Mysql是采用<a href="https://www.cnblogs.com/mengxinJ/p/14211427.html">写前日志</a>）</p><ul><li>避免出现记录错误命令的情况，并且 AOF 写日志也是在主线程中进行的。</ul><h3 id="优缺点"><span class="mr-2">优缺点</span><a href="#优缺点" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>优点<ul><li>故障不丢失，写回策略默认是每秒一次，保证故障最多丢失一秒的数据</ul><li>缺点<ul><li>文件体积较大<li>恢复速度更慢</ul></ul><h3 id="写回硬盘策略"><span class="mr-2">写回（硬盘）策略</span><a href="#写回硬盘策略" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ol><li>Always（总是），每次写操作命令执行完成后，同步将 AOF 日志数据写回硬盘。本质是每次写操作都执行 fsync() 函数。<li>EverySec（每秒），每次写操作命令执行完成后，将命令写入到 AOF 的内核缓冲区，每秒将缓冲区的内容写回到硬盘。本质是每秒创建一个异步任务执行 fsync() 函数。<li>No，意味着交给操作系统控制写回的时机。本质是不执行 fsync() 函数。</ol><h3 id="重写bgrewrite"><span class="mr-2">重写（BGREWRITE）</span><a href="#重写bgrewrite" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>当 AOF文件太大时，Redis fork出一个子进程调用 bgrewriteaof 方法重写一个新的文件，比如increase(1)和increase(1)，会被合并成set(2)。也用到了 <strong>写时复制</strong>。</p><h2 id="rdb"><span class="mr-2">RDB</span><a href="#rdb" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>将某一时刻的内存数据以二进制的形式写入磁盘。</p><p>RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。</p><p>save 和 bgsave 两条命令触发 RDB 持久化操作。save 命令在主线程中执行，会导致阻塞。而 bgsave 创建一个子线程，避免阻塞，是默认的 RDB 的默认配置。并且 bgsave 允许执行快照命令期间修改数据，因为子线程会创建一个修改后的副本再写入（写时复制）。</p><h3 id="优缺点-1"><span class="mr-2">优缺点</span><a href="#优缺点-1" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>优点<ul><li>体积更小，二进制文件<li>恢复更快，适合备份<li>性能更高，只需要fork子进程</ul><li>缺点<ul><li>故障丢失，每隔一段时间（最少五分钟）持久化一次，如果发生故障，意味着这段时间内的所有数据都丢失<li>耐久性差，数据量大的时候，fork会很耗时</ul></ul><h3 id="copy-on-write写时复制"><span class="mr-2">Copy On Write(写时复制)</span><a href="#copy-on-write写时复制" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li><p>原理：fork() 后的子进程与父进程共享内存空间，如果是读取数据，相安无事；<strong>如果是写数据，会检测到内存页是只读然后触发中断最后复制一份数据再做修改</strong>。</p><li><p>好处：减少不必要的资源分配；减少分配和复制大量资源时带来的瞬间延时。</p><li><p>缺点：如果父子进程都在进行大量的写操作，会产生大量的分页错误。</p></ul><h2 id="混合持久化"><span class="mr-2">混合持久化</span><a href="#混合持久化" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>结合 AOF 和 RDB 两种持久化方式。<strong>混合持久化只发生于 AOF 重写过程。</strong> 重写后的新 AOF 文件前半段是 RDB 格式的全量数据，后半段是 AOF 格式的增量数据。</p><p>缺点：不再是 AOF 格式的文件，可读性差。</p><h1 id="数据结构">数据结构</h1><p>Redis 7之后使用 Listpack(紧凑列表) 数据结构代替 Ziplist。</p><p><a href="https://raw.githubusercontent.com/CompetitiveLin/ImageHostingService/picgo/imgs/202309091327817.png" class="popup img-link "><img data-src="https://raw.githubusercontent.com/CompetitiveLin/ImageHostingService/picgo/imgs/202309091327817.png" alt="" class="lazyload" data-proofer-ignore></a></p><ol><li>String: Simple Dynamic String（SDS）<li>List: Quicklist（3.2之后）；LinkedList、Ziplist（3.2之前）<li>Hash: HashTable（哈希表）、<strong>ZipList</strong>。当同时满足以下两个条件的时候，Hash 对象使用 ZipList 编码否则使用 Hashtable：a、每个Field-Value的最大长度小于等于64字节；b、Field-Value最大数量小于512个。<li>Set: HashTable、<strong>Intset</strong>。当同时满足以下两个条件的时候，Set 对象使用 Intset 编码否则使用 Hashtable：a、结合对象保存的所有元素都是整数值；b、集合对象保存的元素数量不超过512个。<li>Sorted set: <strong>ZipList</strong>（压缩列表）、SkipList（<a href="https://juejin.cn/post/6998323950539243533">跳表</a>）。当同时满足以下两个条件的时候，Sorted set 对象使用 ZipList 编码否则使用 SkipList：a、每个元素空间小于64字节；b、集合中元素数量小于128个。<li>Stream: 借鉴 Kafka 的设计，是一个支持多播且可持久化的消息队列。与 PUB/SUB 模式相比，无法持久化。与基于 List LPUSH 和 BRPOP 或 Sorted set 相比，不支持多播分组消费。<li>Bitmap: 位图<li>Hyperloglog: 基数（不重复的元素）统计，但是会存在一定误差。可用于比如注册 IP 数、每日访问 IP 数、页面实时UV、在线用户数，共同好友数等允许一定容错的业务场景。<li>Geospatial index: 实现两个位置距离的计算、获取指定位置附近的元素等功能。</ol><p>消息通信模式：pub/sub，<strong>不支持消息持久化</strong></p><ul><li>基于频道（channel）<li>基于模式（pattern）</ul><p>注意事项：</p><ol><li>客户端需要及时消费，否则会自动断开连接或丢数据<li>连接断开后需要重新连接，否则无法收到消息<li>该消息模式不是一种可靠的消息系统。当出现客户端连接退出，或者极端情况下服务端发生主备切换时，未消费的消息会被丢弃。</ol><h2 id="hash-数据结构下的-rehash-过程"><span class="mr-2">Hash 数据结构下的 <a href="https://cloud.tencent.com/developer/article/1873205">rehash 过程</a>：</span><a href="#hash-数据结构下的-rehash-过程" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ol><li>为 ht[1] 分配空间，作为 rehash 后的哈希表。<li>构造一个索引技术器变量 rehashidx 并初始化为零，表示 rehash 正在执行，否则 rehashidx 为 -1 表示没在进行。<li>在 rehash 期间，<strong>删改查</strong>操作都是先在旧表上操作，并把旧表的数据迁移到新表；新增的操作直接在新表上新增，并且 rehashidx 自增。<li>除此之外，没有增删改查的操作时，还会有一个定时任务周期性（每100ms触发一次）的迁移数据</ol><p>好处：将一次性的大批量拷贝分摊到多个请求中。</p><h1 id="缓冲区">缓冲区</h1><p>共有三个缓冲区：</p><ol><li>客户端输入/输出缓冲区</ol><p>为了解决客户端和服务器端的请求发送和处理速度不匹配所设置的。</p><p>输入缓冲区会先暂存客户端发送过来的命令，Redis 主线程从输入缓冲区中读取命令，进行处理。当 Redis 主线程处理完数据后，会把结果写入到输出缓冲区，再从输出缓冲区返回给客户端。</p><p>缓冲区溢出的可能情况：BigKey，缓冲区大小不合理。</p><ol><li>复制缓冲区，复制积压缓冲区</ol><p>用于Redis主从节点之间复制时使用的。由于主从节点间的数据复制包括<strong>全量复制</strong>和<strong>增量复制</strong>两种。因此也分为<strong>复制缓冲区</strong>和<strong>复制积压缓冲区</strong>两种。</p><ul><li><p>复制缓冲区是 Redis 在全量复制过程中，主节点在向从节点传输 RDB 文件的同时，会继续接收客户端发送的写命令请求。这些写命令就会先保存在复制缓冲区中，等 RDB 文件传输完成后，再发送给从节点去执行。主节点上会为每个从节点都维护一个复制缓冲区，来保证主从节点间的数据同步。</p><li><p>复制积压缓冲区是一个大小有限的环形缓冲区。当服务器断线重连后，复制积压缓冲区的内容会被发送到从节点，当主节点把复制积压缓冲区写满后，会覆盖缓冲区中的旧命令数据，会造成主从节点的数据不一致。在命令传播阶段出现断网的情况，或者网络抖动时会导致连接断开，此时主节点会向复制积压缓冲区写数据。</p></ul><ol><li>AOF 缓冲区，AOF 重写缓冲区</ol><ul><li><p>AOF 缓冲区：Redis在AOF<strong>持久化</strong>的时候，会<strong>先把命令写入到AOF缓冲区</strong>，然后通过回写策略（always、everysec、no）来写入硬盘AOF文件。</p><li><p>AOF 重写缓冲区：当需要进行AOF<strong>重写</strong>时，主进程会fork一个子进程进行AOF重写，此时主进程还要继续接收客户端传来的指令，此时这些指令就会存放在AOF重写缓冲区中；当AOF重写完成后，将AOF重写缓冲区中的指令追加到aof文件中，并将原来的aof文件替换，来保证数据的一致性。（与主从复制中的复制缓冲区类似）</p></ul><h1 id="单线程与多线程">单线程与多线程</h1><p>为什么使用单线程？</p><ul><li>Redis 的瓶颈是内存和带宽，而不是 CPU。</ul><p>为什么又引入了多线程？</p><ul><li>redis 4.0 开始使用多线程惰性删除。<li>redis 6.0 中多线程的实现主要集中在网络 I/O 处理上。采用了混合多线程模型，即在网络 I/O 处理阶段使用多线程。只能执行同时读或同时写</ul><p>在命令执行阶段仍然采用单线程。这种设计既保留了单线程模型的简单性和一致性优势，又充分利用了多线程的并行处理能力。</p><p><a href="https://juejin.cn/post/7015927248100261901">什么是多路IO复用</a>：一个服务端进程可以同时处理多个客户端连接。用于AOF持久化任务和处理客户端请求。其实现函数有：</p><ul><li>select：数据结构是bitmap，采用轮询，限制连接数为1024个（最大文件描述符数量）<li>poll：数据结构是数组，解决了select的个数限制，但依旧是轮询<li>epoll：数据结构是红黑树，使用回调的方式，解决了个数限制，也解决了轮询方式<ol><li>边缘触发（Edge Trigger，ET），更适合高流量或发送大文件的场景，例如 nginx<li>水平触发（Level Trigger，LT），默认，能保证事件一定被处理。</ol></ul><h1 id="高可用主从哨兵集群">高可用（主从，哨兵，集群）</h1><h2 id="主从模式"><span class="mr-2">主从模式</span><a href="#主从模式" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>主节点可以读、写，从节点只能读</p><ol><li>slave启动后，向master发送SYNC命令，master接收到SYNC命令后通过bgsave保存快照，并使用<strong>复制缓冲区记录保存快照这段时间内执行的写命令</strong><li>master将保存的快照文件发送给slave，并继续在复制缓冲区记录执行的写命令<li>slave接收到快照文件后，加载快照文件，载入数据<li>master快照发送完后开始向slave发送缓冲区的写命令，slave接收命令并执行，完成复制初始化<li>此后master每次执行一个写命令都会同步发送给slave，同时也会写入<strong>复制积压缓冲区</strong>，保持master与slave之间数据的一致性，如果主从之间断开连接，那么重连后会根据该缓冲区中的偏移量将断开连接这段时间的数据修改写入从节点。</ol><p>主从异步复制，因此有可能存在数据不一致的情况。</p><h3 id="请求转发"><span class="mr-2">请求转发</span><a href="#请求转发" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>主从模式下，服务端并不做转发处理。而要实现读写分离的功能，需要客户端自行处理了。比如要自行定位master节点，然后将写请求发送过去，读请求则可以做负载均衡处理。</p><h2 id="哨兵模式"><span class="mr-2">哨兵模式</span><a href="#哨兵模式" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>哨兵模式基于主从复制模式，只是引入了哨兵来监控与自动处理故障。</p><p>哨兵每2秒向pubsub频道接收和发送hello信息，实现哨兵之间的通信。</p><p>哨兵每1秒向所有主从节点和其他哨兵发送PING命令来判断其是否正常运行。</p><p>哨兵每10秒向主从节点发送INFO命令来获取节点信息（被标记为客观下线后每1秒一次）。</p><p>如果主节点或者从节点没有在规定的时间内响应哨兵的 PING 命令，哨兵就会将它们标记为「主观下线」。其他哨兵会尝试与节点建立连接，如果大于配置文件中设定的值，则认定节点「客观下线」。</p><h2 id="集群模式"><span class="mr-2">集群模式</span><a href="#集群模式" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>Redis 集群<strong>无法保证强一致性</strong>，选择了高可用和分区容忍，即AP。</p><p>将不同的数据分布在不同的节点中，分布的规则采用<strong>哈希槽算法</strong>。共有 16384 (2^14)个哈希槽。</p><h3 id="不使用一致性哈希算法的原因"><span class="mr-2">不使用一致性哈希算法的原因</span><a href="#不使用一致性哈希算法的原因" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>一致性哈希环是顺时针映射，优先考虑的是<strong>最少的节点数据发生数据迁移</strong><li>哈希槽是静态映射的，优先考虑的问题是<strong>数据均匀分布</strong>，根据不同机器的性能，可以手动分配不同的哈希槽数量到不同机器上</ul><h3 id="请求转发-1"><span class="mr-2">请求转发</span><a href="#请求转发-1" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>在集群模式下，对于读/写请求，并非是服务端转发请求，而是服务端返回转移指令，通知客户端数据所在节点，并让客户端重新发起请求</p><h1 id="事务">事务</h1><p>Redis 有事务但没有回滚，因为Redis认为事务的失败都是使用者造成的。</p><h1 id="缓存雪崩击穿穿透">缓存雪崩、击穿、穿透</h1><ul><li>缓存雪崩：大量缓存失效或 Redis 宕机时，大量请求访问到数据库，导致数据库压力骤增。<ul><li>解决方法：<ol><li>大量失效：均匀设置过期时间或缓存预热<li>宕机：设置 Redis 高可用集群，熔断或限流</ol></ul><li>缓存击穿：热点数据过期，大量请求访问到数据库<ul><li>解决方法：热点数据不设置过期时间</ul><li>缓存穿透：访问的数据既不在缓存中也不在数据库中，被黑客攻击。<ul><li>解决方法：使用<strong>布隆过滤器</strong>快速判断数据是否存在，避免通过查询数据库来判断数据是否存在。</ul></ul><h1 id="缓存策略"><a href="https://juejin.cn/post/7093452218535247886">缓存策略</a></h1><ol><li>Cache-Aside Pattern 旁路缓存模式；读，先从缓存读，未命中从数据库读；写，先写数据库，再写缓存<li>Read/Write-Through Pattern 读/写穿透模式；在旁路缓存模式的基础上封装一层缓存服务，读写操作都调用该缓存服务。读。先从缓存读，未命中数据库读并写到缓存中再返回。<li>Write-Behind Pattern 异步回写模式；与读/写穿透模式类似，缓存系统只同步写缓存，异步批量写数据库</ol><h2 id="旁路缓存下的一致性问题"><span class="mr-2">旁路缓存下的一致性问题</span><a href="#旁路缓存下的一致性问题" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>不存在实时一致性，只能保证最终一致性。</p><p>首选</p><ul><li>写策略：<strong>先更新数据库，再删除缓存</strong>。<li>读策略：先读缓存中数据，如果缓存中没有，则读数据库的数据并且写入缓存中。</ul><p>如果对缓存命中率有要求，可以采用<strong>先更新数据库再更新缓存 + 分布式锁</strong>的方案。分布式锁保证同一时间只运行一个请求更新缓存。</p><p>最终一致性方案：</p><p>主要考虑以下两点：</p><ol><li>第一个操作成功，但第二个失败会有什么问题<li>高并发场景下数据会不会不一致</ol><blockquote><p>如果采用先删除缓存，再更新数据库如何避免出现脏数据？</p></blockquote><p><strong>延迟双删</strong>：先删除缓存，更新数据库，睡眠，再次删除缓存。睡眠的时间一般是一次查询的耗时 + 几百毫秒。第二次的删除可以清除掉因并发导致的缓存脏数据。</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre>#删除缓存
redis.delKey(X)
#更新数据库
db.update(X)
#睡眠
Thread.sleep(N)
#再删除缓存
redis.delKey(X)
</pre></table></code></div></div><p><strong>缓存删除重试</strong>：为了保证缓存删除成功，需要在缓存失败时增加重试机制。可以借助<strong>消息队列</strong>，将删除失败的数据进行异步重试。</p><p><strong>BinLog缓存删除方案</strong>：BinLog存储了对数据库的更改操作日志记录，通过订阅该日志（如：canal），获取需要更新缓存的key和数据。</p><h1 id="过期删除策略和内存淘汰策略">过期删除策略和内存淘汰策略</h1><h2 id="过期删除策略"><span class="mr-2">过期删除策略</span><a href="#过期删除策略" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ol><li>定时删除策略：在设置 key 的过期时间时，同时创建一个定时事件，当时间到达时，由事件处理器自动执行 key 的删除操作。</ol><ul><li>优点：内存可以最快的被释放。<li>缺点：删除过期key会占用 CPU 时间，对 CPU 不友好。</ul><ol><li>惰性删除策略：不主动删除过期键，每次从数据库访问 key 时，都检测 key 是否过期，如果过期则删除该 key。</ol><ul><li>优点：只有在访问的时候检查是否过期，对 CPU 友好。<li>缺点：过期的 key 没被删除，对内存不友好。</ul><ol><li>定期删除策略：每隔一段时间<strong>随机</strong>从数据库中取出一定数量的 key 进行检查，并删除其中的过期key。</ol><ul><li>优点：减少删除操作对 CPU 的影响，也能删除一部分过期的数据。<li>缺点：难以确定定期删除的频率。</ul><p>Redis的删除策略是<strong>惰性删除+定期删除</strong>。定期删除如果检查到过期key的数据超过一定百分比，循环再次检查并删除。</p><h2 id="内存淘汰策略"><span class="mr-2">内存淘汰策略</span><a href="#内存淘汰策略" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ol><li><p>不进行数据淘汰（默认的内存淘汰策略），写入时禁止写入并报错。</p><li><p>进行数据淘汰</p><ol><li>在设置了过期时间的数据中进行淘汰<ul><li>volatile-random： 随机淘汰设置了过期时间的任意键值；<li>volatile-ttl：优先淘汰离过期时间最近的键值；<li>volatile-lru：淘汰所有设置了过期时间的键值中，最久未使用的键值；<li>volatile-lfu：淘汰所有设置了过期时间的键值中，最少使用的键值；</ul><li>在所有数据范围内进行淘汰<ul><li>allkeys-random：随机淘汰任意键值；<li>allkeys-lru：淘汰整个键值中最久未使用的键值；<li>allkeys-lfu：淘汰整个键值中最少使用的键值。</ul></ol></ol><h3 id="近似-lru-算法"><span class="mr-2">近似 LRU 算法</span><a href="#近似-lru-算法" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>出于节省内存的考虑（不需要为所有数据维护一条大链表），Redis 的 LRU 算法并非完整的实现，是一个基于哈希表的近似 LRU 算法，通过对少量键进行取样，然后回收其中的最久未被访问的键。通过调整每次回收时的采样数量 maxmemory-samples，可以实现调整算法的精度。</p><h2 id="redlock-红锁"><span class="mr-2">RedLock 红锁</span><a href="#redlock-红锁" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>红锁是一种分布式锁。在 Redis 单独节点的基础上，RedLock 使用了多个独立的 Redis 的 Master 实例（通常建议是奇数个，比如 5 个），共同协作来提供更强健的分布式锁服务。</p><h3 id="特点"><span class="mr-2">特点</span><a href="#特点" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ol><li>互斥性：任意时刻，只有一个客户端能持有锁<li>防止死锁：持有锁超时，可以释放，防止不必要的资源浪费，也可以防止死锁。<li>可重入性：一个线程如果获取了锁之后,可以再次对其请求加锁。</ol><h3 id="实现思路"><span class="mr-2">实现思路</span><a href="#实现思路" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>RedLock 是对集群的每个节点进行加锁，如果大多数节点（N/2+1）加锁成功，则才会认为加锁成功。</p><p>这样即使集群中有某个节点挂掉了，因为大部分集群节点都加锁成功了，所以分布式锁还是可以继续使用的。</p><h1 id="分布式锁">分布式锁</h1><p>命令：<code class="language-plaintext highlighter-rouge">set nx expire</code>，key 为资源唯一标识符，例如商品 id。value 为线程唯一标识符，例如 requestid。在释放锁时，判断是否与当前线程标识符匹配，再进行释放。</p><h2 id="死锁"><span class="mr-2">死锁</span><a href="#死锁" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>为了防止死锁的出现，需要引入超时机制，设置过期时间</p><h2 id="分布式锁获取失败了"><span class="mr-2">分布式锁获取失败了</span><a href="#分布式锁获取失败了" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>延迟一段时间后重试</p><h2 id="分布式锁超时了但任务还没执行完"><span class="mr-2">分布式锁超时了但任务还没执行完</span><a href="#分布式锁超时了但任务还没执行完" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>答：设置看门狗（定时器）</p><h1 id="大-key-热-key">大 Key/ 热 Key</h1><h2 id="大-key"><span class="mr-2">大 Key</span><a href="#大-key" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>指 Redis 的 Key 对应的 Value 过大，并不是指 Key 过大。</p><h3 id="危害"><span class="mr-2">危害</span><a href="#危害" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ol><li>性能问题：读取大 Key 消耗更多的网络带宽和处理时间<li>引发网络阻塞：如果一个 Key 的大小是 1MB，每秒访问量是 1000，那么每秒会产生 1000 MB 的流量<li>内存分配不均<li>持久化问题：持久化变得更耗时</ol><h3 id="解决方案"><span class="mr-2">解决方案</span><a href="#解决方案" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ol><li>拆分大 Key，将数据分散到多个小 Key 中<li>定期清理或设置过期时间<li>数据压缩<li>选取合适的数据结构</ol><h3 id="如何找到大-key"><span class="mr-2">如何找到大 Key</span><a href="#如何找到大-key" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ol><li>使用 <code class="language-plaintext highlighter-rouge">redis-cli --bigkeys</code> 命令，不建议<li>使用 <code class="language-plaintext highlighter-rouge">scan</code> 命令<li>使用 RdbTools 工具</ol><h3 id="如何删除大-key"><span class="mr-2">如何删除大 Key</span><a href="#如何删除大-key" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ol><li>系统低峰期使用 <code class="language-plaintext highlighter-rouge">del</code> 命令（会造成线程阻塞）<li>使用 <code class="language-plaintext highlighter-rouge">scan</code> 命令（会造成线程阻塞）<li>使用 <code class="language-plaintext highlighter-rouge">unlink</code> 异步删除</ol><h2 id="热-key"><span class="mr-2">热 Key</span><a href="#热-key" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>指短时间内被频繁访问的数据</p><h3 id="危害-1"><span class="mr-2">危害</span><a href="#危害-1" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ol><li>可能会缓存击穿，使存储层访问量激增<li>负载不均衡，热 Key 可能导致某些 Redis 节点负载过高<li>性能瓶颈，占用大量 CPU 资源，影响其他请求</ol><h3 id="解决方案-1"><span class="mr-2">解决方案</span><a href="#解决方案-1" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ol><li>读写分离（最重要）<li>对热点数据分片，分散到不同的 Redis 实例，提升吞吐量</ol><h3 id="如何找到热-key"><span class="mr-2">如何找到热 Key</span><a href="#如何找到热-key" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ol><li>使用 <code class="language-plaintext highlighter-rouge">monitor</code> 命令<li>使用 <code class="language-plaintext highlighter-rouge">redis-cli --hotkeys</code> 命令，不建议</ol><h2 id="为什么100万qps的热key请求可能会影响1000万qps的redis实例"><span class="mr-2">为什么100万QPS的热key请求可能会影响1000万QPS的Redis实例</span><a href="#为什么100万qps的热key请求可能会影响1000万qps的redis实例" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ol><li>100万个请求在单线程的模型下会串行处理，阻塞其他请求<li>热 key 的能承载的QPS是由单个 key 的处理速度决定的<li>1000万QPS可能是集群模式下能承载的请求量</ol></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/backend/'>Backend</a>, <a href='/categories/redis/'>Redis</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/redis/" class="post-tag no-text-decoration" >redis</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Redis%20%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%20-%20Blogs&url=%2Fposts%2Fredis%2F" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Redis%20%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%20-%20Blogs&u=%2Fposts%2Fredis%2F" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=%2Fposts%2Fredis%2F&text=Redis%20%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%20-%20Blogs" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" data-title-succeed="Link copied successfully!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">Recently Updated</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/elasticsearch/">ElasticSearch</a><li><a href="/posts/note-from-work/">Note from Work</a><li><a href="/posts/redis/">Redis 知识体系</a><li><a href="/posts/springboot/">SpringBoot</a><li><a href="/posts/go/">Go 语言学习</a></ul></div><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/backend/">backend</a> <a class="post-tag" href="/tags/c/">c++</a> <a class="post-tag" href="/tags/syntax/">syntax</a> <a class="post-tag" href="/tags/windows-10/">windows 10</a> <a class="post-tag" href="/tags/getting-started/">getting started</a> <a class="post-tag" href="/tags/branch/">branch</a> <a class="post-tag" href="/tags/commits/">commits</a> <a class="post-tag" href="/tags/github/">github</a> <a class="post-tag" href="/tags/java/">java</a> <a class="post-tag" href="/tags/python/">python</a></div></div></div><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">Contents</div><nav id="toc"></nav></div><script src="https://cdn.jsdelivr.net/npm/tocbot@4.20.1/dist/tocbot.min.js"></script></div></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 pl-3 pr-3 pr-xl-4 mt-5"><div id="related-posts" class="mb-2 mb-sm-4"><h3 class="pt-2 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/mysql/"><div class="card-body"> <em class="small" data-ts="1655876004" data-df="ll" > Jun 22, 2022 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>MySQL知识点汇总</h3><div class="text-muted small"><p> 单机QPS 单机 QPS 为 4k 左右。 MySQL select语句执行 prepare 阶段，检查查询语句中的表或字段是否存在，将 * 拓展为表上的所有列。 optimize 阶段，优化器决定使用哪个索引。 execute 阶段，执行器，索引下推。 表空间文件结构 组成：段（默认256MB） -&amp;gt; 区（默认1MB） -&amp;gt; 页（默认16KB） -&amp;gt...</p></div></div></a></div><div class="card"> <a href="/posts/java-syntax/"><div class="card-body"> <em class="small" data-ts="1655046844" data-df="ll" > Jun 12, 2022 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Java知识点记录博客</h3><div class="text-muted small"><p> 运算符优先级 优先级 运算符 1 ( )　[ ] 　. 2 ! 　~　 ++　 – 3 *　 /　 % 4 +　 - 5 ...</p></div></div></a></div><div class="card"> <a href="/posts/java/"><div class="card-body"> <em class="small" data-ts="1655792594" data-df="ll" > Jun 21, 2022 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Basics of Java</h3><div class="text-muted small"><p> 基本知识 三大特点：封装继承多态。 语法糖：switch支持String、泛型、自动拆装箱、变长参数、枚举、内部类、条件编译、断言、数值下划线、for-each、try-with-resources、Lambda表达式 装箱：Integer i = Integer.valueOf(10)， 拆箱：int n = i.intValue() 反射：指动态获取的信息以及动态调用对象的方法的...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/reg-scripts-in-windows/" class="btn btn-outline-primary" prompt="Older"><p>Windows修改注册表脚本</p></a> <a href="/posts/elasticsearch/" class="btn btn-outline-primary" prompt="Newer"><p>ElasticSearch</p></a></div><script type="text/javascript"> $(function () { const origin = "https://giscus.app"; const iframe = "iframe.giscus-frame"; const lightTheme = "light"; const darkTheme = "dark_dimmed"; let initTheme = lightTheme; if ($("html[data-mode=dark]").length > 0 || ($("html[data-mode]").length == 0 && window.matchMedia("(prefers-color-scheme: dark)").matches)) { initTheme = darkTheme; } let giscusAttributes = { "src": "https://giscus.app/client.js", "data-repo": "CompetitiveLin/CompetitiveLin.github.io", "data-repo-id": "R_kgDOG9EeyQ", "data-category": "General", "data-category-id": "DIC_kwDOG9Eeyc4CN-ne", "data-mapping": "pathname", "data-reactions-enabled": "1", "data-emit-metadata": "0", "data-theme": initTheme, "data-input-position": "bottom", "data-lang": "", "crossorigin": "anonymous", "async": "" }; let giscusScript = document.createElement("script"); Object.entries(giscusAttributes).forEach(([key, value]) => giscusScript.setAttribute(key, value)); document.getElementById("tail-wrapper").appendChild(giscusScript); addEventListener("message", (event) => { if (event.source === window && event.data && event.data.direction === ModeToggle.ID) { /* global theme mode changed */ const mode = event.data.message; const theme = (mode === ModeToggle.DARK_MODE ? darkTheme : lightTheme); const message = { setConfig: { theme: theme } }; const giscus = document.querySelector(iframe).contentWindow; giscus.postMessage({ giscus: message }, origin); } }); }); </script></div></div></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/backend/">backend</a> <a class="post-tag" href="/tags/c/">c++</a> <a class="post-tag" href="/tags/syntax/">syntax</a> <a class="post-tag" href="/tags/windows-10/">windows 10</a> <a class="post-tag" href="/tags/getting-started/">getting started</a> <a class="post-tag" href="/tags/branch/">branch</a> <a class="post-tag" href="/tags/commits/">commits</a> <a class="post-tag" href="/tags/github/">github</a> <a class="post-tag" href="/tags/java/">java</a> <a class="post-tag" href="/tags/python/">python</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><footer><div class="container pl-lg-4 pr-lg-4"><div class="d-flex justify-content-between align-items-center text-muted ml-md-3 mr-md-3"><div class="footer-left"><p class="mb-0"> © 2025 <a href="https://github.com/CompetitiveLin">CompetitiveLin</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0">Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js"></script> <script> (function () { function updateMermaid(event) { if (event.source === window && event.data && event.data.direction === ModeToggle.ID) { const mode = event.data.message; if (typeof mermaid === "undefined") { return; } let expectedTheme = (mode === ModeToggle.DARK_MODE ? "dark" : "default"); let config = {theme: expectedTheme}; /* Re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function () { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } let initTheme = "default"; if ($("html[data-mode=dark]").length > 0 || ($("html[data-mode]").length == 0 && window.matchMedia("(prefers-color-scheme: dark)").matches)) { initTheme = "dark"; } let mermaidConf = { theme: initTheme /* <default|dark|forest|neutral> */ }; /* Create mermaid tag */ $("pre").has("code.language-mermaid").each(function () { let svgCode = $(this).children().html(); $(this).addClass("unloaded"); $(this).after(`<pre class=\"mermaid\">${svgCode}</pre>`); }); mermaid.initialize(mermaidConf); window.addEventListener("message", updateMermaid); })(); </script><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lazysizes@5.3.2/lazysizes.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/en.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script> /* see: <https://docs.mathjax.org/en/latest/options/input/tex.html#tex-options> */ MathJax = { tex: { /* start/end delimiter pairs for in-line math */ inlineMath: [ ['$', '$'], ['\\(', '\\)'] ], /* start/end delimiter pairs for display math */ displayMath: [ ['$$', '$$'], ['\\[', '\\]'] ] } }; </script> <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/unregister.js"></script>
