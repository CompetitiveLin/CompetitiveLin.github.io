<!DOCTYPE html><html lang="en" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="theme-color" media="(prefers-color-scheme: light)" content="#f7f7f7"><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1b1b1e"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="viewport" content="width=device-width, user-scalable=no initial-scale=1, shrink-to-fit=no, viewport-fit=cover" ><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="Basics of Java" /><meta property="og:locale" content="en" /><meta name="description" content="基本知识" /><meta property="og:description" content="基本知识" /><link rel="canonical" href="/posts/java/" /><meta property="og:url" content="/posts/java/" /><meta property="og:site_name" content="Blogs" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2022-06-21T14:23:14+08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Basics of Java" /><meta name="twitter:site" content="@CompetitiveLin" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2023-05-07T23:54:58+08:00","datePublished":"2022-06-21T14:23:14+08:00","description":"基本知识","headline":"Basics of Java","mainEntityOfPage":{"@type":"WebPage","@id":"/posts/java/"},"url":"/posts/java/"}</script><title>Basics of Java | Blogs</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Blogs"><meta name="application-name" content="Blogs"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/tocbot@4.20.1/dist/tocbot.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener('change', () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.notify(); } /* flipMode() */ } /* ModeToggle */ const modeToggle = new ModeToggle(); </script><body data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" class="mx-auto"> <img src="/assets/img/avator.jpg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title"> <a href="/">Blogs</a></div><div class="site-subtitle font-italic">Recording everything in here.</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/CompetitiveLin" aria-label="github" target="_blank" rel="noopener noreferrer"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/CompetitiveLin" aria-label="twitter" target="_blank" rel="noopener noreferrer"> <i class="fab fa-twitter"></i> </a> <a href="javascript:location.href = 'mailto:' + ['zee_lin','foxmail.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper"><div id="topbar" class="container d-flex align-items-center justify-content-between h-100 pl-3 pr-3 pl-md-4 pr-md-4"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>Basics of Java</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper" class="d-flex justify-content-center"><div id="main" class="container pl-xl-4 pr-xl-4"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-9 pr-xl-4"><div class="post pl-1 pr-1 pl-md-2 pr-md-2"><h1 data-toc-skip>Basics of Java</h1><div class="post-meta text-muted"> <span> Posted <em class="" data-ts="1655792594" data-df="ll" data-toggle="tooltip" data-placement="bottom"> Jun 21, 2022 </em> </span> <span> Updated <em class="" data-ts="1683474898" data-df="ll" data-toggle="tooltip" data-placement="bottom"> May 7, 2023 </em> </span><div class="d-flex justify-content-between"> <span> By <em> <a href="https://github.com/CompetitiveLin">CompetitiveLin</a> </em> </span><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="13410 words"> <em>74 min</em> read</span></div></div></div><div class="post-content"><h1 id="基本知识">基本知识</h1><p>三大特点：封装继承多态。</p><p>语法糖：switch支持String、泛型、自动拆装箱、变长参数、枚举、内部类、条件编译、断言、数值下划线、for-each、try-with-resources、Lambda表达式</p><p>装箱：<code class="language-plaintext highlighter-rouge">Integer i = Integer.valueOf(10)</code>， 拆箱：<code class="language-plaintext highlighter-rouge">int n = i.intValue()</code></p><p>反射：指动态获取的信息以及动态调用对象的方法的功能。在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性</p><h2 id="object-类的方法"><span class="mr-2">Object 类的方法</span><a href="#object-类的方法" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ol><li>clone()<li>getClass()<li>toString()<li>finalize()<li>equals()<li>hashCode()<li>wait()<li>notify()<li>notifyAll()</ol><h3 id="双等号和-equals-的区别"><span class="mr-2">双等号和 equals() 的区别</span><a href="#双等号和-equals-的区别" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ol><li>针对 String 引用数据类型，<code class="language-plaintext highlighter-rouge">==</code> 是用来判断两个对象的<strong>引用</strong>是否相等，而 <code class="language-plaintext highlighter-rouge">equals()</code> 是判断两个对象的<strong>值</strong>是否相等。<li>基本数据类型没有 <code class="language-plaintext highlighter-rouge">equals()</code> 方法<li>针对自定义对象而言，如果没有重写 <code class="language-plaintext highlighter-rouge">equals()</code> 方法，则两者没有区别，<code class="language-plaintext highlighter-rouge">equals()</code> 内部是通过 <code class="language-plaintext highlighter-rouge">==</code> 来判断。</ol><h3 id="重写-equals-为什么一定要重写-hashcode"><span class="mr-2">重写 equals() 为什么一定要重写 hashCode()</span><a href="#重写-equals-为什么一定要重写-hashcode" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ol><li>对比两个对象是否相等时，先使用 hashCode() 判断，再用 equals() 判断<li>相同的对象一定要有相同的哈希值</ol><p>假设重写 equals() 但没有重写 hashCode()，并且因为 Set 存储的是不重复的对象，依据 hashCode 和 equals 进行先后判断，如果没有重写 hashCode()，则直接认为两个对象不相等。</p><h3 id="为什么不直接使用-hashcode-就确定两个对象是否相等呢"><span class="mr-2">为什么不直接使用 hashCode 就确定两个对象是否相等呢</span><a href="#为什么不直接使用-hashcode-就确定两个对象是否相等呢" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>这是因为不同对象的 hashCode 可能相同；但 hashCode 不同的对象一定不相等，所以使用 hashCode 可以起到快速初次判断对象是否相等的作用。</p><h1 id="内存结构">内存结构</h1><p><a href="https://img-blog.csdnimg.cn/cb59671dff1f4588b5d845f60874013b.png" class="popup img-link "><img data-src="https://img-blog.csdnimg.cn/cb59671dff1f4588b5d845f60874013b.png" alt="" class="lazyload" data-proofer-ignore></a></p><p>运行时数据区域包含线程私有的程序计数器、虚拟机栈、本地方法栈，线程共享的堆（包含字符串常量池）。直接内存（堆外内存）包含元空间（包含类常量池和运行时常量池）。</p><ul><li>程序计数器：与操作系统中的程序计数器类似，为了线程切换后能恢复到正确的执行位置，是唯一一个不会出现 <code class="language-plaintext highlighter-rouge">OutOfMemoryError</code> 的内存区域。<li>虚拟机栈：以帧为单位，帧由局部变量表、操作数栈、动态链接、方法返回地址组成。每一次方法调用都会有一个对应的栈帧被压入栈中，每一个方法调用结束后，都会有一个栈帧被弹出。<ul><li>局部变量表：主要存放了编译期可知的各种数据类型（boolean、byte、char、short、int、float、long、double）、<strong>对象引用</strong>（reference 类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）<li>操作数栈：用于存放方法执行过程中产生的中间计算结果，也存放计算过程中产生的临时变量。<li>动态链接：将常量池中指向方法的符号引用转化为其在内存地址中的直接引用。与类加载中的解析类似。<li>方法返回地址：顾名思义。</ul><li>本地方法栈：和虚拟机栈所发挥的作用非常相似，区别是：虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而<strong>本地方法栈则为虚拟机使用到的 Native 方法（机器码）服务</strong>。<li>堆：唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。<li>字符串常量池：简单理解为用C++实现的默认固定大小为1009的HashTable。在每个VM中只有一份，存放的是字符串常量的引用值 。关于常量池中的String类型的数据，<a href="https://tech.meituan.com/2014/03/06/in-depth-understanding-string-intern.html"><code class="language-plaintext highlighter-rouge">String#intern</code> 的用法</a>。<li>类常量池：每个java文件被编译成class文件后会有一项常量池，用于存放编译器生成的<strong>字面量</strong>和<strong>符号引用</strong>。在<strong>编译</strong>阶段，存放的是常量的<strong>符号引用</strong>。<li>运行时常量池：是在<strong>类加载完成后</strong>，将每个class常量池中的符号引用值转存到运行时常量池中，也就是说，每个class都有一个运行时常量池，类在解析阶段，将符号引用替换成直接引用，与字符串常量池中的引用值保持一致。</ul><h2 id="方法区"><span class="mr-2">方法区</span><a href="#方法区" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="永久代和元空间的区别"><span class="mr-2">永久代和元空间的区别</span><a href="#永久代和元空间的区别" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>在 hotpot 虚拟机中，JDK7以前的方法区是用永久代实现的；在JDK8后，方法区用元空间实现的。最大的区别：元空间位于本地内存上；而永久代位于虚拟机内存中，与堆是连续的一块内存。</p><h3 id="垃圾回收"><span class="mr-2">垃圾回收</span><a href="#垃圾回收" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>只有 Full GC 时执行垃圾回收，主要回收两部分内容：</p><ol><li>常量池中废弃的常量<li>不再使用的类型，类需要同时满足下面 3 个条件才能被卸载：<ol><li>该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。<li>加载该类的 ClassLoader 已经被回收。<li>该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</ol></ol><p><a href="https://blog.csdn.net/xiaojin21cen/article/details/105300521">class常量池、字符串常量池和运行时常量池的区别</a></p><h1 id="内存模型jmm"><a href="https://zhuanlan.zhihu.com/p/258393139">内存模型（JMM）</a></h1><p>JMM 旨在提供一个统一的可参考的规范，屏蔽平台内存访问差异性。这个规范为多线程读写共享变量时如何与内存交互提供了规则和保证。并发编程中，程序会因为 CPU 多级缓存或指令重排序等出现问题，因此需要一些规范要保证并发编程的可靠性。</p><p>关键概念包括：</p><ul><li>主内存：表示所有线程都可以访问的共享内存。线程不能直接读写主内存中的变量。<li>工作内存：每个线程都有自己的工作内存，线程的工作内存保存了该线程用到的变量和主内存共享变量的副本拷贝，线程对变量的操作都在工作内存中进行。当一个线程修改了自己工作内存中的变量时，它必须把这个变量的最新值写回到主内存中，以便其他线程可以看到这个最新的值。<li>共享变量：这些变量可以被多个线程访问。它们可以是实例变量或静态变量。必须存储在主内存中。</ul><p>JMM 为处理共享变量定义了三个特征（多线程中的概念）：</p><ul><li>可见性：当一个线程修改共享变量的值，其他线程能够立即知道被修改了。当变量被 volatile 修饰时，这个变量被修改后会立刻刷新到主内存，当其它线程需要读取该变量时，会去主内存中读取新值。但普通变量读取的仍是旧值。<li>原子性：一个操作是不可分割，不可中断的，一个线程在执行时不会被其他线程干扰。Synchronized 块之间的操作具有原子性<li>顺序性：一个线程观察其他线程中的指令执行顺序，由于指令重排序的存在，该观察结果一般杂乱无序。</ul><h2 id="volatile"><span class="mr-2">volatile</span><a href="#volatile" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>通过内存屏障来保证可见性的</p><ul><li>保证可见性，但不保证原子性！只是确保将变量的更新操作通知到其他线程。不能一定能保证线程安全。<li>禁止指令重排，背景：为了提高性能，编译器和处理器常常会对指令重排。禁止指令重排避免了多线程环境下程序出现乱序执行的现象。</ul><h2 id="happens-before"><span class="mr-2">happens-before</span><a href="#happens-before" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>happens-before原则定义如下：</p><ol><li>如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。<li>两个操作之间存在happens-before关系，并不意味着一定要按照happens-before原则制定的顺序来执行。<strong>重排序之后的执行结果</strong>与按照happens-before关系来执行的结果一致即可。</ol><h2 id="as-if-serial"><span class="mr-2">as-if-serial</span><a href="#as-if-serial" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>As-if-serial的意思是所有的语句都可以为了优化而被重排序，但是必须保证它们重排序后的结果和程序代码本身的应有结果是一致的。为保证as-if-serial语义，Java异常处理机制也会为重排序做一些特殊处理。</p><h2 id="八种内存交互操作"><span class="mr-2">八种内存交互操作</span><a href="#八种内存交互操作" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p><a href="https://raw.githubusercontent.com/CompetitiveLin/ImageHostingService/picgo/imgs/202311261917698.png" class="popup img-link "><img data-src="https://raw.githubusercontent.com/CompetitiveLin/ImageHostingService/picgo/imgs/202311261917698.png" alt="" class="lazyload" data-proofer-ignore></a></p><h2 id="内存屏障"><span class="mr-2">内存屏障</span><a href="#内存屏障" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ol><li>LoadLoad 屏障：对于这样的语句Load1，LoadLoad，Load2。在Load2及后续读取操作要读取的数据被访问前，保证Load1要读取的数据被读取完毕。<li>StoreStore屏障：对于这样的语句Store1， StoreStore， Store2，在Store2及后续写入操作执行前，保证Store1的写入操作对其它处理器可见。<li>LoadStore 屏障：对于这样的语句Load1， LoadStore，Store2，在Store2及后续写入操作被刷出前，保证Load1要读取的数据被读取完毕。<li>StoreLoad 屏障：对于这样的语句Store1， StoreLoad，Load2，在Load2及后续所有读取操作执行前，保证Store1的写入对所有处理器可见。</ol><p>在每个volatile读操作后插入LoadLoad屏障，在读操作后插入LoadStore屏障。</p><p>在每个volatile写操作的前面插入一个StoreStore屏障，后面插入一个SotreLoad屏障。</p><div class="table-wrapper"><table><thead><tr><th> <th> <tbody><tr><td><a href="https://raw.githubusercontent.com/CompetitiveLin/ImageHostingService/picgo/imgs/202311261939595.png" class="popup img-link "><img data-src="https://raw.githubusercontent.com/CompetitiveLin/ImageHostingService/picgo/imgs/202311261939595.png" alt="" class="lazyload" data-proofer-ignore></a><td><a href="https://raw.githubusercontent.com/CompetitiveLin/ImageHostingService/picgo/imgs/202311261939251.png" class="popup img-link "><img data-src="https://raw.githubusercontent.com/CompetitiveLin/ImageHostingService/picgo/imgs/202311261939251.png" alt="" class="lazyload" data-proofer-ignore></a></table></div><h1 id="类的生命周期">类的生命周期</h1><ul><li>加载：通过类的全限定名（包名 + 类名）获取class文件的二进制字节流（通过类加载器来完成，其加载过程使用<a href="https://www.51cto.com/article/647617.html"><strong>双亲委派模型</strong></a>），将其转化为方法区运行时的数据结构，最后在堆中实例化一个java.lang.Class对象，作为方法区中这个类的信息的入口。<li>连接<ul><li>验证：确保被加载的类的正确性<li>准备：为类的<strong>静态变量</strong>分配内存并设为jvm的<strong>默认值</strong>（不同于下文的初值，基本类型为零，引用类型为null，final修饰的常量为设定的值），对于非静态的变量，则不会为它们分配内存。<li>解析：虚拟机将常量池中的符号引用替换为直接引用，主要针对类或接口，字段，类方法，方法类型等。举例：使用内存地址（直接引用）指向方法名（符号引用）代替方法名。</ul><li>初始化：按照顺序自上而下运行类中的变量赋值语句和静态语句，如果有父类，则首先按照顺序运行父类中的变量赋值语句和静态语句在类的初始化阶段，只会初始化与类相关的静态赋值语句和静态语句。类变量（静态变量）在方法区分配内存，并设置<strong>初值</strong>。<li>使用：包括主动引用和被动引用。直接引用就会触发类的初始化，其中包括以下四种情况：<ol><li>通过new关键字实例化对象、读取或设置类的静态变量、调用类的静态方法。<li>初始化子类的时候，会触发父类的初始化。<li>作为程序入口直接运行时（也就是直接调用main方法）。<li>通过反射方式执行以上三种行为。</ol><li>卸载：需要同时满足以下三个条件：该类所有的实例都已经被回收，即Java堆中不存在该类的任何实例；加载该类的ClassLoader已经被回收；该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。<a href="https://blog.csdn.net/zhengzhb/article/details/7331354">单例对象不会被JVM垃圾回收</a>，因为无法满足卸载的第一个条件，Java堆中会始终存在该单例的实例。</ul><h1 id="类加载器">类加载器</h1><p>线程上下文类加载器：破坏了“双亲委派模型”，可以在执行线程中抛弃双亲委派加载链模式，使程序可以逆向使用类加载器，例如SPI (Service Provider Interface)。SPI<strong>接口</strong>中的代码经常需要加载具体的<strong>实现类</strong>。SPI接口是Java核心库的一部分，由 <strong>启动类加载器(Bootstrap Classloader)</strong> 来加载，而实现类由 <strong>系统类加载器(AppClassLoader)</strong> 来加载。</p><p><a href="https://raw.githubusercontent.com/CompetitiveLin/ImageHostingService/picgo/imgs/202305071548284.png" class="popup img-link "><img data-src="https://raw.githubusercontent.com/CompetitiveLin/ImageHostingService/picgo/imgs/202305071548284.png" alt="" class="lazyload" data-proofer-ignore></a></p><p>双亲委派机制概念：双亲委派机制是指当一个类加载器收到某个类加载请求时，该类加载器首先会把请求委派给父类加载器。每个类加载器都是如此，它会先委托父类加载器在自己的搜索范围内找不到对应的类时，该类加载器才会尝试自己去加载。</p><p>双亲委派机制的作用：保证Java类的加载的一致性和安全性，避免了类的重复加载和恶意代码的替换。</p><p>Tomcat中的类加载器：</p><ul><li>Tomcat自身所使用的类加载器，会加载jre的lib包及tomcat的lib包的类，遵循双亲委派机制。加载顺序：(1).先从缓存中加载；(2).如果没有，则从JVM的Bootstrap类加载器加载；(3).如果没有，则从父类加载器加载，加载顺序是AppClassLoader、Common、Shared。(4).如果没有，则从当前类加载器加载（按照WEB-INF/classes、WEB-INF/lib的顺序）；<li>每个Web应用程序用的，每个web应用程序都有自己专用的WebappClassLoader，优先加载/web-inf/lib下的jar中的class文件，这样就隔离了每个web应用程序的影响，不遵循双亲委派机制。加载顺序：(1).先从缓存中加载；(2).如果没有，则从JVM的Bootstrap类加载器加载；(3).如果没有，则从当前类加载器加载（按照WEB-INF/classes、WEB-INF/lib的顺序）；(4).如果没有，则从父类加载器加载，由于父类加载器采用默认的委派模式，所以加载顺序是AppClassLoader、Common、Shared。</ul><p>Java的SPI：SPI 的本质是将接口实现类的全限定名配置在文件中，并由服务加载器读取配置文件，加载实现类。当服务的提供者提供了服务接口的一种实现之后，在jar包的META-INF/services/目录里同时创建一个以服务接口命名的文件。该文件里就是实现该服务接口的具体实现类。而当外部程序装配这个模块的时候，就能通过该jar包META-INF/services/里的配置文件找到具体的实现类名，并装载实例化，完成模块的注入。</p><h2 id="对象的创建过程"><span class="mr-2">对象的创建过程</span><a href="#对象的创建过程" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ol><li>类加载检查<li>分配内存：指针碰撞或空闲列表<ul><li>当多个对象并发争抢空间时，有两种解决办法：CAS 和本地线程分配缓冲（TLAB，默认方式）</ul><li>初始化零值<li>设置对象头<li>执行构造方法</ol><h2 id="对象的内存布局"><span class="mr-2">对象的内存布局</span><a href="#对象的内存布局" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ol><li>对象头，两部分组成：存储自身运行时数据如哈希码，GC分代年龄；指向类的类型指针<li>实例数据，真正存储有效信息的部分<li>对齐填充，起占位作用</ol><h2 id="对象的定位访问针对jvm虚拟机栈中的局部变量表"><span class="mr-2"><a href="https://javaguide.cn/java/jvm/memory-area.html#%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D">对象的定位访问（针对JVM虚拟机栈中的局部变量表）</a></span><a href="#对象的定位访问针对jvm虚拟机栈中的局部变量表" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ol><li>句柄，Java 堆中将会划分出一块内存来作为句柄池，局部变量表 reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与对象类型数据各自的具体地址信息。<li>直接指针，局部变量表里 reference 中存储的直接就是对象的地址。</ol><h1 id="垃圾回收-1">垃圾回收</h1><p>JVM触发GC时，首先会让所有的用户线程到达安全点SafePoint时阻塞，也就是STW，然后枚举根节点，即找到所有的GC Roots，通过可达性算法向下搜寻活跃对象，可达的对象就保留，<strong>不可达的对象就回收</strong>。</p><p><a href="https://blog.csdn.net/qq_32099833/article/details/109253339">可达性算法</a>：</p><ul><li>引用计数算法<li>可达性分析</ul><h2 id="哪些对象可以作为gc-roots"><span class="mr-2">哪些对象可以作为GC Roots</span><a href="#哪些对象可以作为gc-roots" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>虚拟机栈(栈帧中的本地变量表)中引用的对象<li>本地方法栈(Native 方法)中引用的对象<li>方法区中类静态属性引用的对象<li>方法区中常量引用的对象<li>所有被同步锁持有的对象</ul><h2 id="内存分配和回收原则"><span class="mr-2">内存分配和回收原则</span><a href="#内存分配和回收原则" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>对象优先在Eden区分配<li>大对象直接进入老年代<li>长期存活的进入老年代</ul><h2 id="gc-分类"><span class="mr-2">GC 分类</span><a href="#gc-分类" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>Partial GC<ul><li>Minor GC：只对新生代进行垃圾收集<li>Major GC：只对老年代进行垃圾收集<li>Mixed GC：整个新生代和部分老年代，只有G1收集器有</ul><li>Full GC：整个Java堆和方法区</ul><h3 id="full-gc-触发条件"><span class="mr-2">Full GC 触发条件</span><a href="#full-gc-触发条件" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ol><li>老年代空间不足<li>创建大对象，Eden 区域放不下大对象，直接进入老年代<li>Minor GC 后，存活对象进入老年代<li>调用 system.gc()，系统会建议执行 FGC<li>空间分配担保机制失败，老年代连续可用空间不足</ol><h2 id="空间担保策略"><span class="mr-2">空间担保策略</span><a href="#空间担保策略" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>空间担保策略是 JVM 的一种机制，发生 Minor GC 之前，虚拟机会检查老年代最大可用的连续空间是否大于新生代所有对象的总空间。如果小于，则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败。如果HandlePromotionFailure=true，那么会继续检查老年代最大可用连续空间是否大于历次晋升到老年代的对象的平均大小，如果大于，则尝试进行一次Minor GC，但这次Minor GC依然是有风险的；如果小于或者HandlePromotionFailure=false，则改为进行一次Full GC。</p><h2 id="垃圾收集算法"><span class="mr-2">垃圾收集算法</span><a href="#垃圾收集算法" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>标记——清除算法：顾名思义，标记可回收的对象并清除。<li>标记——复制算法：将内存分成大小相同的两份，需要垃圾收集时，将存活的对象复制到另一份内存中，缺点：内存缩小为原来的一半。<li>标记——整理算法：标记可回收的对象，将存活的对象向一端移动，适合老年代这种垃圾回收频率不高的场景。<li>分代收集算法：在新生代和老年代不同的代用不同的垃圾收集算法。</ul><h2 id="垃圾收集器"><span class="mr-2"><a href="https://cloud.tencent.com/developer/article/1592943">垃圾收集器</a></span><a href="#垃圾收集器" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ol><li>Serial 收集器，单线程、复制算法的新生代收集器<li>ParNew 收集器，多线程、复制算法的新生代收集器，老年代采用Serial Old收集器<li>Parallel Scavenge 收集器，多线程、<strong>复制算法</strong>的新生代收集器，高吞吐量。<li>Serial Old 收集器，单线程、标记-整理算法的老年代收集器。<li>Parallel Old 收集器，多线程、<strong>标记-整理算法</strong>的老年代收集器。<li>CMS(Concurrent Mark Sweep) 收集器，标记-清除算法，以获取最短回收停顿时间为目标的收集器。JDK14正式移除。<li>G1(Garbage-First) 收集器，标记-整理 + 复制算法，内存碎片的产生率大大降低。JDK9-JDK17的默认垃圾收集器。</ol><p><a href="https://raw.githubusercontent.com/CompetitiveLin/ImageHostingService/picgo/imgs/202305091408302.png" class="popup img-link "><img data-src="https://raw.githubusercontent.com/CompetitiveLin/ImageHostingService/picgo/imgs/202305091408302.png" alt="" class="lazyload" data-proofer-ignore></a> <em>G1收集器内存模型</em></p><p>垃圾收集器发展历程：</p><ul><li>JDK8 默认 Parallel Scavenge（标记-复制） + Parallel Old（标记整理）<li>JDK9 默认 G1<li>JDK11 提出 ZGC<li>JDK14 CMS 被移除</ul><p>CMS（Concurrent Mark Sweep）收集器： 基于标记-清除算法，在Minor GC时会暂停所有的应用线程，并以多线程的方式进行垃圾回收。在Full GC时不再暂停应用线程，而是使用若干个后台线程定期的对老年代空间进行扫描。</p><ul><li>步骤：<ol><li>初始标记（CMS initial mark）：有STW，但速度很快<li>并发标记（CMS concurrent mark）：从GC Roots的直接关联对象开始遍历整个对象图<li>重新标记（CMS remark）：STW，为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录；采用三色标记算法和增量更新避免漏标<li>并发清除（CMS concurrent sweep）：清理删除掉标记阶段判断的已经死亡的对象</ol><li>优点：并发收集，低停顿<li>缺点：<ol><li>工作时会占用一部分CPU资源而导致用户程序变慢，降低总吞吐量<li>无法清除浮动垃圾<li>基于<strong>标记-清除</strong>算法会导致内存碎片不断增多，在分配大对象时有可能会提前触发一次Full GC。<li>停顿时间不可预期</ol></ul><p>Garbage First（G1）收集器：</p><ul><li>特点：引入<strong>分区</strong>的思路，弱化了分代的概念，并合理利用垃圾收集各个周期的资源。<li>内存结构：堆内存被切分为多个固定大小的区域，最小为1M，最大为32M，默认2048份。<li>内存分配：每个区域被标记为E、S、O和H，分别表示Eden，Survivor，Old，Humongous。Humongous区域是为了那些存储超过50%标准region大小的对象而设计的，它用来专门存放巨型对象。如果一个H区装不下一个巨型对象，那么G1会寻找连续的H分区来存储。为了能找到连续的H区，有时候不得不启动Full GC。<li>执行特点：<ul><li>并行与并发：使用多个CPU核缩短Stop The World停顿时间。<li>空间整合：从整体来看是基于“<strong>标记-整理</strong>”算法实现的收集器；从局部上来看是基于“标记-复制”算法实现的。<li>可观测的停顿：能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在垃圾收集上的时间不得超过 N 毫秒。<li>G1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region(这也就是它的名字 Garbage-First 的由来) 。</ul><li>步骤：<ol><li>初始标记（Initial Marking），STW，标记一下 GC Roots 能直接关联到的对象。<li>并发标记（Concurrent Marking），从 GC Root 开始对堆中对象进行可达性分析，找到存活对象。<li>最终标记（Final Marking），为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，STW，但是可并行执行。<li>筛选回收（Live Data Counting and Evacuation），对各个Region中的回收价值和成本进行排序并制定回收计划。</ol><li>优点：保持高回收率的同时，减少停顿</ul><p><a href="https://raw.githubusercontent.com/CompetitiveLin/ImageHostingService/picgo/imgs/202305091525435.png" class="popup img-link "><img data-src="https://raw.githubusercontent.com/CompetitiveLin/ImageHostingService/picgo/imgs/202305091525435.png" alt="" class="lazyload" data-proofer-ignore></a></p><p>一个线程 OOM 后，其他线程仍能正常运行，因为 OOM 之前会 GC，释放掉资源。</p><h1 id="jvm调优"><a href="https://cloud.tencent.com/developer/beta/article/1812722">JVM调优</a></h1><ol><li>选择合适的垃圾收集器：CPU单核，只能选择Serial；CPU多核，关注吞吐量 ，那么选择<a href="https://juejin.cn/post/6986571159902879751">Parallel Scavenge（标记复制） + Paralle Old（标记整理）</a>组合；CPU多核，关注用户停顿时间，JDK版本1.6或者1.7，内存小，那么选择CMS。CPU多核，关注用户停顿时间，JDK1.8及以上，JVM可用内存6G以上，那么选择G1。<li>调整内存大小，现象：垃圾收集频率非常频繁。<li>设置符合预期的停顿时间，现象：程序间接性的卡顿。参数：<code class="language-plaintext highlighter-rouge">-XX:MaxGCPauseMillis</code><li>调整内存区域大小比率，现象：某一个区域的GC频繁，其他都正常。参数：<code class="language-plaintext highlighter-rouge">-XX:SurvivorRatio=6, -XX:NewRatio=4</code><li>提升老年代年龄标准，现象：老年代频繁GC，每次回收的对象很多。参数：<code class="language-plaintext highlighter-rouge">-XX:InitialTenuringThreshol=7</code><li>调整大对象的标准，现象：老年代频繁GC，每次回收的对象很多，而且单个对象的体积都比较大。参数：<code class="language-plaintext highlighter-rouge">-XX:PretenureSizeThreshold=1000000//新生代可容纳的最大对象,大于则直接会分配到老年代，0代表没有限制。</code><li>调整GC的触发时机，现象：CMS收集器的情况下，G1 经常 Full GC，程序卡顿严重。<li>调整JVM本地内存（直接内存）大小，现象：堆内存空间充足，但是报OOM</ol><p>调优的一条经验总结：</p><blockquote><p>将新对象预留在新生代，由于 Full GC 的成本远高于 Minor GC，因此尽可能将对象分配在新生代是明智的做法，实际项目中根据 GC 日志分析新生代空间大小分配是否合理，适当通过“-Xmn”命令调节新生代大小，最大限度降低新对象直接进入老年代的情况。</p></blockquote><p><a href="https://raw.githubusercontent.com/CompetitiveLin/ImageHostingService/picgo/imgs/202305111608659.png" class="popup img-link "><img data-src="https://raw.githubusercontent.com/CompetitiveLin/ImageHostingService/picgo/imgs/202305111608659.png" alt="" class="lazyload" data-proofer-ignore></a></p><h1 id="java-io">Java IO</h1><ol><li>BIO：同步阻塞IO，使用方便，但并发处理能力低<li>NIO：同步非阻塞IO，适用于连接数目多且连接比较短（轻操作）的架构<li>AIO：异步非阻塞IO，适用于连接数目多且连接比较长（重操作）的架构</ol><ul><li>阻塞/非阻塞，是对同一个线程来说。关注的是程序在等待调用结果（消息，返回值）时的状态。阻塞调用是指调用结果返回之前，当前线程会被挂起。非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。<li>同步/异步，针对调用者与被调用者，它们是线程之间的关系。同步操作，调用者需要等待被调用者返回结果，才会进行下一步操作；异步操作，调用者不需要等待被调用者返回调用，即可进行下一步操作，被调用者通常依靠事件、回调等机制来通知调用者结果</ul><p>NIO vs IO:</p><ul><li>IO是面向字节流的，NIO是面向缓冲区的<li>IO流是阻塞的，NIO流是不阻塞的<li>选择器：Java NIO的选择器允许一个单独的线程来监视多个输入通道</ul><p>IO多路复用（事件驱动）：<strong>一个线程不断轮询多个socket的状态</strong>，只有当socket真正有读写状态时，借用当前线程或者使用线程池额外启动线程，调用实际的IO读写操作。</p><p>Java NIO:</p><ul><li>实际上也是一种多路复用的IO。<li>三大核心部分：Channel(通道) ，Buffer(缓冲区), Selector(选择器)，Channel 负责传输（类比成铁路）， Buffer 负责存取数据（类比成载着货物的火车）<ul><li>Channel是双向的，数据总是从通道读到缓冲区或者从缓冲区中写入通道内。</ul><li>额外一个Selector线程，用于监听多个通道（Channel）的事件（比如：连接打开，数据到达），如果由事件发生，则获取事件并对每个事件进行相应的响应处理。</ul><h1 id="并发编程">并发编程</h1><p>一个 Java 程序的运行是 main 线程和多个其他线程同时运行。</p><h2 id="多线程"><span class="mr-2">多线程</span><a href="#多线程" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="completablefuture"><span class="mr-2">CompletableFuture</span><a href="#completablefuture" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>CompletableFuture 最大的特点是支持函数式编程，可以通过回调的方式处理计算结果、链式组合异步任务等。当异步任务完成或者发生异常时，自动调用回调对象的回调方法。</p><h3 id="wait-和-sleep-区别"><span class="mr-2">wait() 和 sleep() 区别</span><a href="#wait-和-sleep-区别" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ol><li>sleep() 是 Thread 的静态方法，wait() 是 Object 的普通 final 方法<li>wait() 方法需要在synchronize块或者synchronize方法里调用，作用是释放锁，然而sleep不需要<li>sleep() 是休眠，wait() 是挂起<li>wait() 唤醒需要用 notify() 或者 notifyAll() ，而 sleep() 则是休眠一段时间自己就恢复<li>如果需要线程停顿，使用 sleep()；使用 wait() 进行线程间的通信</ol><h3 id="synchronized"><span class="mr-2">synchronized</span><a href="#synchronized" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ol><li>修饰普通方法/静态方法：通过 Access flags 的标记符实现同步<li>修饰代码块：通过 monitorenter 和 monitorexit 指令实现同步</ol><p>底层都是通过对象头里 Mark Word 指向的对象监听器（Monitor）实现的，再底层是操作系统的互斥量（mutex）实现的</p><p>同一时刻只能有一个线程运行 synchronized(lock) 内的代码块，其他线程会否则<strong>阻塞</strong>。PS：获取锁（运行代码块），释放锁（阻塞代码块）</p><ol><li>wait(): 获取锁并使线程进入等待状态<li>notify(): 随机唤醒一个在等待锁释放（<code class="language-plaintext highlighter-rouge">wait()</code>）的线程<li>notifyAll(): 唤醒所有正在等待锁释放（<code class="language-plaintext highlighter-rouge">wait()</code>）的线程，</ol><p>注意：notify() 或 notifyAll() 必须等到退出 synchronized() 或 wait() 后才释放锁！</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre>synchronized (obj) {
    // 条件不满足
    while (condition does not hold) {
        obj.wait();
    }
    // 执行满足条件的代码
    obj.notifyAll();
}
</pre></table></code></div></div><p>or</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre>synchronized (obj) {
  while (true){
    // 条件满足
    if (condition holds){
      // 执行满足条件的代码
      obj.notifyAll();
    }
    obj.wait();
  }
}
</pre></table></code></div></div><p>synchronized 可以用来修饰非静态方法（普通方法）、静态方法、代码块，锁住的是 class 对象的对象头！</p><p>run() 和 start() 的区别:</p><ul><li>run()，调用普通方法，并不开启新线程。<li>start()，启动新线程，由JVM调用线程的run()方法。</ul><p>Synchronized 和 Lock 的区别：</p><ol><li>Lock 是一个接口，Synchronized 是一个关键字<li>Lock 需要手动释放锁，Synchronized 会自动释放锁<li>Lock 可以是公平锁/非公平锁，Synchronized 只能是非公平锁<li>Lock 有多种获取锁的方式，例如一定时间内获取不到会返回，Synchronized 获取不到锁一直会阻塞<li>性能方面，在竞争激烈的情况下，Lock 的性能会比 Synchronized 好</ol><p>RenentantLock：</p><ul><li>Lock：拿不到锁会一直等待<li>tryLock：去尝试获取锁，获取不到返回 false</ul><h2 id="守护线程daemon-thread"><span class="mr-2">守护线程（Daemon Thread）</span><a href="#守护线程daemon-thread" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>Java 中的线程分为两种：</p><ol><li>用户线程。<li>守护线程，其主要作用是为用户线程服务，比如垃圾回收线程，就是最典型的守护线程。在JVM中，所有非守护线程都执行完毕后，无论有没有守护线程，虚拟机都会自动退出。也就是守护线程拥有自动结束自己生命周期的特性，而非守护线程不具备这个特点。</ol><p>集合框架：</p><ul><li>Collection<ul><li>Set<li>List<li>Queue</ul><li>Map</ul><p>线程安全的list：</p><ul><li>vector<li>CopyOnWriteArrayList 读多写少的情况<li>Collections.synchronizedList() 读少写多的情况</ul><p><a href="https://zhuanlan.zhihu.com/p/151027796">HashMap 知识点</a></p><ul><li>HashMap（JDK8）: 乱序，数组+链表+红黑树+尾插法，链表长度大于8并且数组长度大于64时转红黑树，红黑树节点个数小于6转链表。JDK7时用数组+链表+头插法（可能造成循环链表）实现。<li>LinkedHashMap: 按插入顺序排序<li>TreeMap: 按字典序排序，因为是按字典序排序的，所以键肯定不能为null，值可以为null<li>IdentityHashMap：利用哈希表实现Map接口，不同的是，其比较键（或值）时，使用引用相等性代替对象相等性。<li>ConcurrentSkipListMap：基于跳表的线程安全的，实现快速查找的链表结构。</ul><p><a href="https://zhuanlan.zhihu.com/p/151027796">HashMap面试题</a></p><p>为什么计算哈希值采用低十六位和高十六位异或操作：</p><p>计算数组下标是与操作，只有低 n 位进行与操作，高位不参与任何操作 -&gt; 为了增大散列程度减小哈希碰撞，因此将高十六位参与进哈希值的计算。</p><p><code class="language-plaintext highlighter-rouge">put()</code> 的流程：</p><ol><li>hashcode的高十六位和低十六位进行异或运算<li><code class="language-plaintext highlighter-rouge">(n - 1) &amp; hash</code> 计算数组下标，当 n 为二次幂时，等价于取余操作 <code class="language-plaintext highlighter-rouge">(n - 1)&amp; hash = hash % n</code>。<li>判断当前下标是否有元素，若有元素，使用尾插法。再根据链表长度判断是否需要转换成红黑树。</ol><p>第一次扩容：执行第一次 <code class="language-plaintext highlighter-rouge">put()</code> 操作时，如果数组为空便会执行第一次扩容操作，初始化数组容量为默认大小。</p><p>扩容的过程：</p><ol><li>将数组扩容成原数组的两倍<li>如果没有哈希冲突的节点，使用 <code class="language-plaintext highlighter-rouge">e.hash&amp;(newCap - 1)</code> 计算新的桶位置<li>如果是链表，使用 <code class="language-plaintext highlighter-rouge">e.hash&amp;oldCap</code> 并且判断是否等于零（本质上判断最高位结果是否为零）<li>如果最高位结果是0，桶位置不变<li>如果最高位结果是1，桶位置是原位置 + 扩容长度</ol><p>Set:</p><ul><li>HashSet: 乱序，基于HashMap实现<li>LinkedHashSet: 按插入的顺序排序，基于LinkedHashMap实现<li>TreeSet: 按字典序排序，基于红黑树</ul><p>NULL key AND NULL value:</p><ul><li>key<ul><li>HashMap、LinkedHashMap 能使用 null key<li>ConcurrentHashMap、TreeMap、HashTable 不能使用 null key。</ul><li>value<ul><li>HashMap、LinkedHashMap、TreeMap 能使用 null value<li>Hashtable、ConcurrentHashMap 不能使用 null value。</ul></ul><p>为什么ConcureentHashMap的key和value都不能为null：</p><ul><li>value不能为null：多线程情况下需要杜绝二义性。二义性是指当返回null时，无法判断是存在value为null的key还是不存在key从而返回null。因为单线程中可以使用 <code class="language-plaintext highlighter-rouge">containsKey()</code> 解决，但是多线程下无法使用同样的方法，因为可能会有其他线程进行其他操作<strong>影响返回值</strong>。</ul><p>ConcurrentHashMap JDK7 vs JDK8</p><ul><li>JDK7: 数组 + 链表。先定位 Segment，再定位桶。底层结构是继承了ReentrantLock的Segment数组。可以看成是由线程安全的HashMap组成的一个map数组，数组的长度决定了支持的最大的并发量。<li>JDK8: 数组 + 链表 + 红黑树。可以直接定位到桶。链表中的元素超过8并且数组长度大于64后，将链表结构转换成红黑树。<ol><li>使用 volatile 修饰Node的值和Next数组以保证值变化时对于其他线程是可见的<li>使用 table 数组的头结点作为 synchronized 的锁来保证写操作的安全<li>当头结点为 null 时，使用 CAS 操作来保证数据能正确的写入。</ol></ul><p><a href="https://raw.githubusercontent.com/CompetitiveLin/ImageHostingService/picgo/imgs/202305151605481.png" class="popup img-link "><img data-src="https://raw.githubusercontent.com/CompetitiveLin/ImageHostingService/picgo/imgs/202305151605481.png" alt="" class="lazyload" data-proofer-ignore></a></p><p>HashTable速度慢：使用synchronized对整个对象加锁。</p><p>JDK7：<strong>对整个数组进行分段</strong>(每段都是由若干个 hashEntry 对象组成的链表)，每个分段都有一个 Segment 分段锁(继承 ReentrantLock 分段锁)。与hashtable相比，加锁粒度更细，但是初始化Segment数组长度后就无法扩容。ConcurrentHashMap 是一个二级哈希表。在一个总的哈希表下面，有若干个子哈希表。</p><p><a href="https://raw.githubusercontent.com/CompetitiveLin/ImageHostingService/picgo/imgs/202305161016705.png" class="popup img-link "><img data-src="https://raw.githubusercontent.com/CompetitiveLin/ImageHostingService/picgo/imgs/202305161016705.png" alt="" class="lazyload" data-proofer-ignore></a></p><p>JDK8：<strong>对table数组的头节点加锁</strong>（哈希桶为空时，使用CAS将新的Node写入哈希桶的首节点；哈希桶不为空时，使用synchronized对首节点加锁接着添加节点）</p><ul><li>put：分两步，计算哈希值和一个死循环，循环步骤，<ol><li>first节点还没有初始化，所以初始化first节点，然后进入下次循环；<li>first节点初始化了,但是为空，<strong>采用CAS方式把当前要put的值设置进这处，设置失败则进入下次循环，成功则保存成功，退出循环；</strong><li>如果判断有其他线程正在对ConcurrentHashMap扩容（hash==MOVED），获取要去获取新的tab，进入下次循环；<li>找到了对应哈希桶的首节点f，直接<strong>对f加synchronized同步</strong>，然后判断f节点是链表结构还是红黑树结构，链表结构则遍历链表进行设置，红黑树则采用红黑树设置进去。设置成功后判断是否需要把链表结构转红黑树；</ol><li>get: 大部分情况下不加锁，是通过 volatile 修饰 Node 成员 val 保证的。与 volatile 修饰桶数组无关，桶数组用 volatile 修饰主要是保证在数组扩容的时候保证可见性。仅当节点为红黑树、正在变色旋转、查询非头节点时，会加基于 CAS 实现的读写锁。</ul><p>ThreadLocal: 提供线程内的局部变量，在多线程的环境中保证各个线程内的变量不同。将数据封闭在线程中而避免使用同步，即线程封闭。一个ThreadLocal对象即是一个线程局部变量。jdbc连接池就是用ThreadLocal，典型例子。以下使四种方法：</p><ul><li>Object get()：获取该线程局部变量的值。<li>void set(Object value)：给该线程局部变量赋值。<li>protected Object initialValue()：返回该线程局部变量的初始值，该方法是一个protected的方法，显然是为了让子类覆盖而设计的。<li>public void remove()：将当前线程局部变量的值删除。</ul><p>底层是 <code class="language-plaintext highlighter-rouge">ThreadLocalMap</code> 内部静态类，由数组实现，解决 hash 冲突的方式采用的是线性探测法</p><p>存在内存泄漏的原因：由于 ThreadLocalMap 的生命周期跟 Thread 一样长，如果没有手动删除对应 key 就会导致该 key 的value 永远无法被访问，造成内存泄漏</p><p>正确使用方法：</p><ol><li>每次使用完ThreadLocal都调用它的remove()方法清除数据，防止 ThreadLocalMap 中 Entry 一直保持对 value 的强引用，导致 value 不能被回收<li>将ThreadLocal变量定义成private static，这样就一直存在ThreadLocal的强引用，也就能保证任何时候都能通过ThreadLocal的弱引用访问到Entry的value值，进而清除掉</ol><h1 id="线程池">线程池</h1><p>线程池的七个参数：</p><ol><li><p>核心线程数（corePoolSize）： 核心线程数是线程池中保持活动状态的线程数。即使没有任务需要执行，核心线程也不会被回收。当有新任务提交时，如果核心线程都在忙碌，则会创建新的线程来处理任务。</p><li><p>最大线程数（maximumPoolSize）： 最大线程数是线程池中允许的最大线程数。当工作队列满了并且活动线程数达到最大线程数时，如果还有新任务提交，线程池将创建新的线程来处理任务。但是，超过最大线程数的线程可能会导致资源消耗过大。</p><li><p>空闲线程存活时间（keepAliveTime）： 空闲线程存活时间指的是非核心线程在没有任务执行时的最长存活时间。当线程池中的线程数超过核心线程数且空闲时间达到设定值时，多余的线程将被终止，直到线程池中的线程数不超过核心线程数。</p><li><p>时间单位（unit）： 时间单位是用于表示核心线程数和空闲线程存活时间的单位。常见的时间单位包括秒、毫秒、分钟等。</p><li><p>工作队列（workQueue）： 工作队列用于存储待执行的任务。当线程池中的线程都在忙碌时，新提交的任务将被添加到工作队列中等待执行。常见的工作队列类型有直接提交队列（SynchronousQueue）、任务优先队列（PriorityBlockingQueue）、有界队列（ArrayBlockingQueue）和无界队列（LinkedBlockingQueue）等。</p><li><p>线程工厂（threadFactory）： 线程工厂用于创建新线程。线程工厂提供了创建线程的方法，可以自定义线程的名称、优先级等属性。</p><li><p>拒绝策略（rejectedExecutionHandler）： 拒绝策略定义了当线程池无法接受新任务时的处理策略。当工作队列已满且线程池中的线程数已达到最大线程数时，新任务将被拒绝执行。常见的拒绝策略有丢弃、丢弃最旧的任务、抛出异常等。</p><ol><li>AbortPolicy 拒绝任务并抛出一个异常 RejectedExecutionException<li>DiscardPolicy 拒绝任务，不抛出异常。<li>DiscardOldestPolicy 把老的任务丢掉，执行新任务。<li>CallerRunsPolicy 直接调用线程处理该任务。</ol></ol><p>JDK四种线程池：</p><ul><li>newCachedThreadPool，可根据需要创建新线程的线程池<li>newSingleThreadExecutor，单线程池<li>newFixedThreadPool，创建固定大小的线程池<li>newScheduledThreadPool，创建一个大小无限的线程池</ul><p>线程池执行顺序：</p><ol><li>首先判断 corePoolSize 是否已满，如果没有满，那么就去创建一个线程去执行该任务；否则请看下一步<li>如果线程池的核心线程数已满，那么就继续判断 BlockingQueue 是否已满，如果没满，那么就将任务放到任务队列中；否则请看下一步<li>如果任务队列已满，那么就判断线程池中的线程数量是否达到了maxumunPoolSize，如果没达到，那么就创建线程去执行该任务；否则请看下一步；<li>如果线程池已满，那么就根据拒绝策略来做出相应的处理；</ol><p>简而言之：<strong>corePool-&gt;workQueue-&gt;maxPool</strong></p><p><a href="https://raw.githubusercontent.com/CompetitiveLin/ImageHostingService/picgo/imgs/202305171352348.png" class="popup img-link "><img data-src="https://raw.githubusercontent.com/CompetitiveLin/ImageHostingService/picgo/imgs/202305171352348.png" alt="" class="lazyload" data-proofer-ignore></a></p><p>线程池被回收：线程池也是在堆中也是一个对象，一定要调用shutdown()</p><p>线程池何时回收线程：getTask()的返回值为null时</p><ol><li>未调用shutdown()，并且当前工作线程数过多<li>调用shutdown()，缓冲队列中的线程为空</ol><p>shutdown() 和 shutdownNow() 的区别：</p><ol><li>shutdown(): 将线程池状态置为SHUTDOWN，停止接受新的任务并且执行完所有任务后停止<li>shutdownNow(): 将线程池状态置为STOP，停止接受新的任务、忽略队列中等待的任务、<strong>尝试中断</strong>（interrupt）正在运行的任务、返回未执行的任务列表</ol><p>submit() 和 execute() 的区别：submit() 内部仍然是调用 execute() 方法，只不过 submit() 方法会获取任务返回值和异常信息。</p><p>核心线程数设置：</p><ol><li>CPU密集型任务：CPU核心数 + 1：这样设置线程池的大小能实现 CPU 的最优利用率。即使当计算密集型的线程偶尔由于页缺失故障或者其他原因暂停时，这个 “额外” 的线程也能确保CPU 的时装周期不会被浪费。<li>IO密集型任务：CPU核心数 * 2<li>混合型任务：CPU核心数 * （1 + IO耗时/CPU耗时）</ol><h1 id="锁">锁</h1><ol><li>乐观锁，悲观锁：<ul><li>乐观锁，修改数据前比较数据是否被修改过。CAS，原子类的递增操作，适合频繁读<li>悲观锁，加锁使其他线程无法修改。synchronized和lock的实现类，适合频繁写</ul><li>自旋锁，非自旋锁：获取同步资源的锁失败，资源被占用（上下文切换，也就是线程的唤醒和阻塞是十分耗时的）<ul><li>自旋锁，不放弃CPU时间片，通过自旋等待锁的释放，但自旋超过一定次数（默认10次）仍没有获得锁，那么线程被挂起。线程竞争不激烈并且锁持有的时间不长时，可以使用自旋锁。<li>非自旋锁，线程会进入阻塞状态</ul><li>无锁，偏向锁，轻量级锁，重量级锁：指针对synchronized同步锁的状态，锁可以升级但不能降级。<ul><li>偏向锁，通过对比Mark Word中是否存储着指向当前线程的偏向锁以解决加锁问题，避免执行CAS操作来加锁和解锁，Java15放弃偏向锁。使用背景：锁不仅不存在多线程竞争，而且总是由同一个线程多次获取，那么在同一个线程反复获取所释放锁中，其中并还没有锁的竞争。<li>轻量级锁，通过用CAS修改Mark Word操作和<strong>自旋</strong>来解决加锁问题，避免线程阻塞和唤醒而影响性能。<li>重量级锁，将除了拥有锁的线程以外的线程都阻塞。</ul></ol><p>锁升级的过程：当有线程访问同步块时，无锁升级为偏向锁；当有锁竞争时，升级为轻量级锁；当自旋十次失败，升级为重量级锁。</p><ol><li>公平锁，非公平锁：<ul><li>公平锁，每个线程获取锁的顺序是按照线程访问锁的先后顺序获取的。<li>非公平锁，线程获取锁时并不会遵循先来先得的规则，可以插队（并不是随意的插队，而是在合适的时机插队）。当后到的线程请求锁时，该锁恰好被释放，则该锁被后到的线程拥有。</ul><li>可重入锁（递归锁），非可重入锁：ReentrantLock和synchronized都是可重入锁，<strong>NonReentrantLock是非可重入锁</strong><ul><li>可重入锁，指在同一个线程在外层方法获取锁的时候，再进入该线程的内层方法可以再次获取锁（前提锁对象得是同一个对象或者class），不会因为之前已经获取过还没释放而阻塞。好处是避免死锁。<li>非可重入锁，如果一个方法中获取锁并调用另外方法，那么在调用另外方法前需要释放锁。</ul><li>独享锁（排它锁），共享锁<ul><li>独享锁，ReentrantLock、synchronized、ReentrantReadWriteLock的写锁<li>共享锁，ReentrantReadWriteLock的读锁，可以再加共享锁但不可以加排他锁！</ul></ol><p>Synchronized（同步锁）：属于独占锁、悲观锁、可重入锁、非公平锁。</p><p>ReentrantLock：继承了Lock类，两者都是可重入锁、悲观锁、独占锁、默认非公平锁。</p><h2 id="abstractqueuedsynchronizeraqs"><span class="mr-2"><a href="https://www.cnblogs.com/jimoer/p/13747291.html">AbstractQueuedSynchronizer（AQS）</a></span><a href="#abstractqueuedsynchronizeraqs" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>该类是一个抽象类，采用<strong>模板方法</strong>的设计模式，规定了<strong>独占</strong>和<strong>共享</strong>模式需要实现的方法。</p><p>简单解释：通过 CAS 修改 volatile 修饰的int值 state（该值代表竞争资源标识） + 一个存放等待锁的线程队列。其定义了两种资源共享模式：</p><ol><li><p>独占式。ReentrantLock 是独占式的锁资源。初始化 state = 0，表示资源未被锁定，调用 <code class="language-plaintext highlighter-rouge">lock()</code> 方法时state的值加一，并且当 state = 0 才表明其他线程有机会获取锁。</p><li><p>共享式。ReentrantWriteLock 和 CountDownLatch 是共享锁模式。CountDownLatch 会将任务分成 N 个子任务，初始化 state = N，每个子线程完成任务后会减一，直到为零。</p></ol><h2 id="锁消除"><span class="mr-2">锁消除</span><a href="#锁消除" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>指Java虚拟机在即时编译时，通过对运行上下的扫描，消除那些不可能存在共享资源竞争的锁。锁消除可以节约无意义的请求锁时间。</p><h2 id="锁粗化"><span class="mr-2">锁粗化</span><a href="#锁粗化" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>一直对某个对象反复加锁和解锁，频繁地进行互斥同步操作也会引起不必要的性能消耗。如果虚拟机检测到有一系列操作都是对某个对象反复加锁和解锁，会将加锁同步的范围粗化到整个操作序列的外部。</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre>//==== 粗化前 ===
for(int i=0;i&lt;n;i++){
    synchronized(lock){
    }
}
//==== 粗化后 ===
synchronized(lock){
    for(int i=0;i&lt;n;i++){
    }
}
</pre></table></code></div></div><p>接口和抽象类的区别：</p><ul><li>相同点：<ul><li>都不能被实例化<li>接口的实现类或抽象类的子类都只有实现了接口或抽象类中的方法后才能实例化</ul><li>不同点：<ul><li>接口是对行为的抽象（强调特定功能的实现），抽象类是对物体的抽象（强调所属关系）。<li>接口只有定义，不能有方法的实现，java 1.8中可以定义default方法体，而抽象类可以有定义与实现，方法可在抽象类中实现。<li>实现接口的关键字为implements，继承抽象类的关键字为extends。一个类可以实现多个接口，但一个类只能继承一个抽象类。所以，使用接口可以间接地实现多重继承。<li>接口成员变量默认为public static final，必须赋初值，不能被修改；其所有的成员方法都是public、abstract的。抽象类中成员变量默认default，可在子类中被重新定义，也可被重新赋值；抽象方法被abstract修饰，不能被private、static、synchronized和native等修饰，必须以分号结尾，不带花括号。</ul></ul><h1 id="static修饰词">static修饰词</h1><p>java中静态属性和静态方法可以被继承，但是不能被重写，因此不能实现多态。</p><p>静态常量/静态变量/静态方法是用static修饰的常量/变量/方法，其<strong>从属于类</strong>。另外，static是不允许用来修饰局部变量的。</p><ul><li><p>静态方法可以调用静态变量，但不能调用非静态变量，因为静态方法在类加载时就分配了内存，而非静态变量是在对象实例化时才分配内存。</p><li><p>非静态方法可以调用静态变量，也可以调用非静态变量。</p></ul><h3 id="静态初始化块初始化块和构造方法的区别"><span class="mr-2">静态初始化块、初始化块和构造方法的区别</span><a href="#静态初始化块初始化块和构造方法的区别" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>执行顺序：静态初始化块 &gt; 初始化块 &gt; 构造方法</p><p><strong>非静态初始化块（构造代码块）：</strong></p><p>作用：给对象进行初始化。对象一建立就运行，且优先于构造函数的运行。</p><p><em>与构造函数的区别：</em></p><p>非静态初始化块给所有对象进行统一初始化，构造函数只给对应对象初始化。</p><p>应用：将所有构造函数共性的东西定义在构造代码块中。</p><p><strong>静态初始化块：</strong></p><p>作用：给类进行初始化。随着类的加载而执行，且只执行一次</p><p><em>与构造代码块的区别：</em></p><ul><li>构造代码块用于初始化对象，每创建一个对象就会被执行一次；静态代码块用于初始化类，随着类的加载而执行，不管创建几个对象，都只执行一次。<li>静态代码块优先于构造代码块的执行<li>都定义在类中，一个带static关键字，一个不带static</ul><h1 id="泛型和泛型擦除">泛型和泛型擦除</h1><p>泛型：参数化类型，指在定义一个类、接口或者方法时可以指定类型参数。</p><p>泛型擦除：是指Java中的泛型只在编译期有效，在运行期间会被删除。也就是说所有泛型参数在编译后都会被清除掉。</p><p>在编译器编译后，泛型的转换规则如下：</p><ul><li>List、List 擦除后的类型为 List；<li>List[]、List[] 擦除后的类型为 List[]；<li>List&lt;? extends E&gt;、List&lt;? super E&gt; 擦除后的类型为 List；<li>List&lt;T extends Serialzable &amp; Cloneable&gt; 擦除后类型为 List。</ul><h1 id="jdk-设计模式"><a href="https://www.cnblogs.com/vipstone/p/18361126">JDK 设计模式</a></h1><ol><li>单例模式：<code class="language-plaintext highlighter-rouge">java.lang</code> Runtime 类使用饿汉式创建单例<li>工厂模式：<code class="language-plaintext highlighter-rouge">java.util.concurrent</code> ThreadFactory 接口使用工厂模式创建线程<li>代理模式：<code class="language-plaintext highlighter-rouge">java.lang.reflect</code> Proxy 类使用动态代理<li>迭代器模式：<code class="language-plaintext highlighter-rouge">java.util</code> Iterator 接口使用迭代器遍历集合容器<li>模板方法模式：<code class="language-plaintext highlighter-rouge">java.util.concurrent.locks</code> AQS 中的 <code class="language-plaintext highlighter-rouge">tryAcquire</code>, <code class="language-plaintext highlighter-rouge">tryRelease</code>, <code class="language-plaintext highlighter-rouge">tryAcquireShared</code>, <code class="language-plaintext highlighter-rouge">tryReleaseShared</code> 方法被公平锁和非公平锁重写<li>建造者模式：线程不安全的 <code class="language-plaintext highlighter-rouge">StringBuilder</code> 和线程安全的 <code class="language-plaintext highlighter-rouge">StringBuffer</code><li>装饰器模式 + 适配器模式<ol><li>装饰器模式：通过组合替代继承的方式在不改变原始类的情况下<strong>添加增强功能</strong>，例如 <code class="language-plaintext highlighter-rouge">FilterInputStream</code> 和 <code class="language-plaintext highlighter-rouge">FilterOutputStream</code> 用于增强 <code class="language-plaintext highlighter-rouge">InputStream</code> 和 <code class="language-plaintext highlighter-rouge">OutputStream</code> 的功能。<li>适配器模式：字符流对象和字节流对象的<strong>相互适配</strong></ol></ol></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/backend/'>Backend</a>, <a href='/categories/java/'>Java</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/java/" class="post-tag no-text-decoration" >java</a> <a href="/tags/backend/" class="post-tag no-text-decoration" >backend</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Basics%20of%20Java%20-%20Blogs&url=%2Fposts%2Fjava%2F" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Basics%20of%20Java%20-%20Blogs&u=%2Fposts%2Fjava%2F" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=%2Fposts%2Fjava%2F&text=Basics%20of%20Java%20-%20Blogs" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" data-title-succeed="Link copied successfully!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">Recently Updated</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/elasticsearch/">ElasticSearch</a><li><a href="/posts/note-from-work/">Note from Work</a><li><a href="/posts/redis/">Redis 知识体系</a><li><a href="/posts/springboot/">SpringBoot</a><li><a href="/posts/go/">Go 语言学习</a></ul></div><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/backend/">backend</a> <a class="post-tag" href="/tags/c/">c++</a> <a class="post-tag" href="/tags/syntax/">syntax</a> <a class="post-tag" href="/tags/windows-10/">windows 10</a> <a class="post-tag" href="/tags/getting-started/">getting started</a> <a class="post-tag" href="/tags/branch/">branch</a> <a class="post-tag" href="/tags/commits/">commits</a> <a class="post-tag" href="/tags/github/">github</a> <a class="post-tag" href="/tags/java/">java</a> <a class="post-tag" href="/tags/python/">python</a></div></div></div><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">Contents</div><nav id="toc"></nav></div><script src="https://cdn.jsdelivr.net/npm/tocbot@4.20.1/dist/tocbot.min.js"></script></div></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 pl-3 pr-3 pr-xl-4 mt-5"><div id="related-posts" class="mb-2 mb-sm-4"><h3 class="pt-2 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/java-syntax/"><div class="card-body"> <em class="small" data-ts="1655046844" data-df="ll" > Jun 12, 2022 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Java知识点记录博客</h3><div class="text-muted small"><p> 运算符优先级 优先级 运算符 1 ( )　[ ] 　. 2 ! 　~　 ++　 – 3 *　 /　 % 4 +　 - 5 ...</p></div></div></a></div><div class="card"> <a href="/posts/springboot/"><div class="card-body"> <em class="small" data-ts="1691651312" data-df="ll" > Aug 10, 2023 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>SpringBoot</h3><div class="text-muted small"><p> Spring, SpringBoot, Spring MVC 区别： Spring框架(Framework)是最流行的Java应用程序开发框架。 Spring框架的主要功能是依赖项注入或控制反转(IoC)。 Spring MVC是Spring的一个MVC框架，包含前端视图，文件配置等。XML和config配置比较复杂。 Spring Boot 是为简化Spring配置的快速开发...</p></div></div></a></div><div class="card"> <a href="/posts/kafka-vs-rocketmq/"><div class="card-body"> <em class="small" data-ts="1692954622" data-df="ll" > Aug 25, 2023 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Kafka vs RocketMQ</h3><div class="text-muted small"><p> 基本概念 RocketMQ 由 Producer, Brocker, Consumer 组成 Producer 负责生产消息 Consumer 负责消费消息 Broker 负责存储消息，每一个 Broker 对应一台服务器但可以存储多个 Topic 的消息，每个 Topic 的消息也分片存储在不同的 Broker 里。 ...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/java-syntax/" class="btn btn-outline-primary" prompt="Older"><p>Java知识点记录博客</p></a> <a href="/posts/mysql/" class="btn btn-outline-primary" prompt="Newer"><p>MySQL知识点汇总</p></a></div><script type="text/javascript"> $(function () { const origin = "https://giscus.app"; const iframe = "iframe.giscus-frame"; const lightTheme = "light"; const darkTheme = "dark_dimmed"; let initTheme = lightTheme; if ($("html[data-mode=dark]").length > 0 || ($("html[data-mode]").length == 0 && window.matchMedia("(prefers-color-scheme: dark)").matches)) { initTheme = darkTheme; } let giscusAttributes = { "src": "https://giscus.app/client.js", "data-repo": "CompetitiveLin/CompetitiveLin.github.io", "data-repo-id": "R_kgDOG9EeyQ", "data-category": "General", "data-category-id": "DIC_kwDOG9Eeyc4CN-ne", "data-mapping": "pathname", "data-reactions-enabled": "1", "data-emit-metadata": "0", "data-theme": initTheme, "data-input-position": "bottom", "data-lang": "", "crossorigin": "anonymous", "async": "" }; let giscusScript = document.createElement("script"); Object.entries(giscusAttributes).forEach(([key, value]) => giscusScript.setAttribute(key, value)); document.getElementById("tail-wrapper").appendChild(giscusScript); addEventListener("message", (event) => { if (event.source === window && event.data && event.data.direction === ModeToggle.ID) { /* global theme mode changed */ const mode = event.data.message; const theme = (mode === ModeToggle.DARK_MODE ? darkTheme : lightTheme); const message = { setConfig: { theme: theme } }; const giscus = document.querySelector(iframe).contentWindow; giscus.postMessage({ giscus: message }, origin); } }); }); </script></div></div></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/backend/">backend</a> <a class="post-tag" href="/tags/c/">c++</a> <a class="post-tag" href="/tags/syntax/">syntax</a> <a class="post-tag" href="/tags/windows-10/">windows 10</a> <a class="post-tag" href="/tags/getting-started/">getting started</a> <a class="post-tag" href="/tags/branch/">branch</a> <a class="post-tag" href="/tags/commits/">commits</a> <a class="post-tag" href="/tags/github/">github</a> <a class="post-tag" href="/tags/java/">java</a> <a class="post-tag" href="/tags/python/">python</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><footer><div class="container pl-lg-4 pr-lg-4"><div class="d-flex justify-content-between align-items-center text-muted ml-md-3 mr-md-3"><div class="footer-left"><p class="mb-0"> © 2025 <a href="https://github.com/CompetitiveLin">CompetitiveLin</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0">Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js"></script> <script> (function () { function updateMermaid(event) { if (event.source === window && event.data && event.data.direction === ModeToggle.ID) { const mode = event.data.message; if (typeof mermaid === "undefined") { return; } let expectedTheme = (mode === ModeToggle.DARK_MODE ? "dark" : "default"); let config = {theme: expectedTheme}; /* Re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function () { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } let initTheme = "default"; if ($("html[data-mode=dark]").length > 0 || ($("html[data-mode]").length == 0 && window.matchMedia("(prefers-color-scheme: dark)").matches)) { initTheme = "dark"; } let mermaidConf = { theme: initTheme /* <default|dark|forest|neutral> */ }; /* Create mermaid tag */ $("pre").has("code.language-mermaid").each(function () { let svgCode = $(this).children().html(); $(this).addClass("unloaded"); $(this).after(`<pre class=\"mermaid\">${svgCode}</pre>`); }); mermaid.initialize(mermaidConf); window.addEventListener("message", updateMermaid); })(); </script><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lazysizes@5.3.2/lazysizes.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/en.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script> /* see: <https://docs.mathjax.org/en/latest/options/input/tex.html#tex-options> */ MathJax = { tex: { /* start/end delimiter pairs for in-line math */ inlineMath: [ ['$', '$'], ['\\(', '\\)'] ], /* start/end delimiter pairs for display math */ displayMath: [ ['$$', '$$'], ['\\[', '\\]'] ] } }; </script> <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/unregister.js"></script>
