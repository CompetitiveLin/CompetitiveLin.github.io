---
title: Leetcode-754. 到达终点数字
categories: [Leetcode, Medium]
tags: [leetcode, ]
date: 2022-11-04T14:13:32+800
last_modified_at: 
pin: false
---

题目来源：[754. 到达终点数字](https://leetcode.cn/problems/reach-a-number/)

## Description

在一根无限长的数轴上，你站在 `0` 的位置。终点在 `target` 的位置。

你可以做一些数量的移动 `numMoves` :

每次你可以选择向左或向右移动。
第 `i` 次移动（从  `i == 1` 开始，到 `i == numMoves` ），在选择的方向上走 `i` 步。
给定整数 `target` ，返回 *到达目标所需的 **最小** 移动次数(即最小 `numMoves` )* 。


**示例1：**

<pre>
<strong>输入：</strong>target = 2
<strong>输出：</strong>3
<strong>解释：</strong>
第一次移动，从 0 到 1 。
第二次移动，从 1 到 -1 。
第三次移动，从 -1 到 2 。
</pre>

**示例2：**

<pre>
<strong>输入：</strong>target = 3
<strong>输出：</strong>2
<strong>解释：</strong>
第一次移动，从 0 到 1 。
第二次移动，从 1 到 3 。
</pre>

**提示：**

- -10<sup>9</sup> <= target <= 10<sup>9</sup>
- `target != 0`


## Solution

数学方法。假设没有向左移动的操作，那么最远可以达到 `1 + 2 + 3 + ... + n`，如果有左移操作，那么可以发现每次左移减少的距离都是偶数，即 `-1 + 2 + 3 + ... + n` 或 `-1 + -2 + 3 +...+ n` 等。那么最小移动步骤则是**最远距离（1 + ... + n) - target为偶数时的最小n**。


## Code
```java
class Solution {
    public int reachNumber(int target) {
        int ans = 0, sum = 0;
        target = target > 0 ? target : -target;
        while(sum < target || (sum  - target) % 2 == 1) sum += ++ans;
        return ans;
    }
}
```
