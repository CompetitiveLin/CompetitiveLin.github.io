---
title: Redis 知识体系
categories: [Backend, Redis]
tags: [redis]
date: 2023-07-06T19:24:40+800
last_modified_at: 
pin: false
---

# 持久化

- 数据结构

  - [跳跃表](https://juejin.cn/post/6998323950539243533)

# 高可用（主从，哨兵，集群）
## 主从模式
主节点可以读、写，从节点只能读
1. slave启动后，向master发送SYNC命令，master接收到SYNC命令后通过bgsave保存快照，并使用缓冲区记录保存快照这段时间内执行的写命令
2. master将保存的快照文件发送给slave，并继续记录执行的写命令
3. slave接收到快照文件后，加载快照文件，载入数据
4. master快照发送完后开始向slave发送缓冲区的写命令，slave接收命令并执行，完成复制初始化
5. 此后master每次执行一个写命令都会同步发送给slave，保持master与slave之间数据的一致性

## 哨兵模式
哨兵模式基于主从复制模式，只是引入了哨兵来监控与自动处理故障。


# 事务
Redis 有事务但没有回滚，因为Redis认为事务的失败都是使用者造成的。


# 缓存雪崩、击穿、穿透
- 缓存雪崩：大量缓存失效或 Redis 宕机时，大量请求访问到数据库，导致数据库压力骤增。
  - 解决方法：
    1. 大量失效：均匀设置过期时间或缓存预热
    2. 宕机：设置 Redis 高可用集群，熔断或限流
- 缓存击穿：热点数据过期，大量请求访问到数据库
  - 解决方法：热点数据不设置过期时间
- 缓存穿透：访问的数据既不在缓存中也不在数据库中，被黑客攻击。
  - 解决方法：使用**布隆过滤器**快速判断数据是否存在，避免通过查询数据库来判断数据是否存在。

# 数据库缓存一致性

不存在实时一致性，只能保证最终一致性。

首选
- 写策略：**先更新数据库，再删除缓存**。
- 读策略：先读缓存中数据，如果缓存中没有，则读数据库的数据并且写入缓存中。

如果对缓存命中率有要求，可以采用**先更新数据库再更新缓存 + 分布式锁**的方案。分布式锁保证同一时间只运行一个请求更新缓存。

最终一致性方案：

**延迟双删**：先删除缓存，更新数据库，睡眠，再次删除缓存。睡眠的时间一般是一次查询的耗时 + 几百毫秒。第二次的删除可以清除掉因并发导致的缓存脏数据。
```
#删除缓存
redis.delKey(X)
#更新数据库
db.update(X)
#睡眠
Thread.sleep(N)
#再删除缓存
redis.delKey(X)
```

**缓存删除重试**：为了保证缓存删除成功，需要在缓存失败时增加重试机制。可以借助**消息队列**，将删除失败的数据进行异步重试。

**BinLog缓存删除方案**：BinLog存储了对数据库的更改操作日志记录，通过订阅该日志（如：canel），获取需要更新缓存的key和数据。