---
title: Leetcode-1106. 解析布尔表达式
categories: [Leetcode, Hard]
tags: [leetcode, ]
date: 2022-11-05T19:12:53+800
last_modified_at: 
pin: false
---

题目来源：[1106. 解析布尔表达式](https://leetcode.cn/problems/parsing-a-boolean-expression/)

给你一个以字符串形式表述的 [布尔表达式](https://baike.baidu.com/item/%E5%B8%83%E5%B0%94%E8%A1%A8%E8%BE%BE%E5%BC%8F/1574380?fr=aladdin)（boolean） `expression`，返回该式的运算结果。

有效的表达式需遵循以下约定：

*   `"t"`，运算结果为 `True`
*   `"f"`，运算结果为 `False`
*   `"!(expr)"`，运算过程为对内部表达式 `expr` 进行逻辑  **非的运算** （NOT）
*   `"&(expr1,expr2,...)"`，运算过程为对 2 个或以上内部表达式 `expr1, expr2, ...` 进行逻辑  **与的运算** （AND）
*   `"|(expr1,expr2,...)"`，运算过程为对 2 个或以上内部表达式 `expr1, expr2, ...` 进行逻辑  **或的运算** （OR）

 **示例 1：** 

```
输入：expression = "!(f)"
输出：true
```

 **示例 2：** 

```
输入：expression = "|(f,t)"
输出：true
```

 **示例 3：** 

```
输入：expression = "&(t,f)"
输出：false
```

 **示例 4：** 

```
输入：expression = "|(&(t,f,t),!(t))"
输出：false
```

 **提示：** 

*   `1 <= expression.length <= 20000`
*   `expression[i]` 由 `{'(', ')', '&', '|', '!', 't', 'f', ','}` 中的字符组成。
*   `expression` 是以上述形式给出的有效表达式，表示一个布尔值。


## Solution

栈模拟。

一个栈存储运算符号，一个栈存储 `t`, `f`, `(` 三个符号。


## Code
```java
class Solution {
    public boolean parseBoolExpr(String expression) {
        HashMap<Character, Boolean> map = new HashMap<>();
        map.put('t', true);
        map.put('f', false);
        ArrayDeque<Character> stack = new ArrayDeque<>();
        ArrayDeque<Character> symbol = new ArrayDeque<>();
        for(int i = 0; i < expression.length(); i++){
            char c = expression.charAt(i);
            if(c == '|' || c == '!' || c == '&') symbol.push(c);
            else if(c == '(' || c == 't' || c == 'f') stack.push(c);
            else if(c == ',') continue;
            else if(c == ')'){
                char temp = stack.poll();
                boolean res = map.get(temp);
                char temp_symbol = symbol.poll();
                if(temp_symbol == '!') res = !res;
                temp = stack.poll();
                while(temp != '('){
                    if(temp_symbol == '|') res |= map.get(temp);
                    else if(temp_symbol == '&') res &= map.get(temp);
                    temp = stack.poll();
                }
                stack.push(res == true? 't' : 'f');
            }
        }
        return map.get(stack.peek());
    }
}
```
