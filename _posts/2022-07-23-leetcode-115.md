---
title: Leetcode-剑指 Offer II 115. 重建序列
categories: [Leetcode, Medium]
tags: [leetcode, topological sorting]
date: 2022-07-23T13:48:46+800
last_modified_at: 
pin: false
---

题目来源：[剑指 Offer II 115. 重建序列](https://leetcode.cn/problems/ur2n8P/)

## Description

给定一个长度为 n 的整数数组 nums ，其中 nums 是范围为 [1，n] 的整数的排列。还提供了一个 2D 整数数组 sequences ，其中 sequences[i] 是 nums 的子序列。
检查 nums 是否是唯一的最短 超序列 。最短 超序列 是 长度最短 的序列，并且所有序列 sequences[i] 都是它的子序列。对于给定的数组 sequences ，可能存在多个有效的 超序列 。

例如，对于 sequences = [[1,2],[1,3]] ，有两个最短的 超序列 ，[1,2,3] 和 [1,3,2] 。
而对于 sequences = [[1,2],[1,3],[1,2,3]] ，唯一可能的最短 超序列 是 [1,2,3] 。[1,2,3,4] 是可能的超序列，但不是最短的。
如果 nums 是序列的唯一最短 超序列 ，则返回 true ，否则返回 false 。
子序列 是一个可以通过从另一个序列中删除一些元素或不删除任何元素，而不改变其余元素的顺序的序列。


**示例1：**

<pre>
<strong>输入：</strong>nums = [1,2,3], sequences = [[1,2],[1,3]]
<strong>输出：</strong>false
<strong>解释：</strong>有两种可能的超序列：[1,2,3]和[1,3,2]。
序列 [1,2] 是[1,2,3]和[1,3,2]的子序列。
序列 [1,3] 是[1,2,3]和[1,3,2]的子序列。
因为 nums 不是唯一最短的超序列，所以返回false。
</pre>

**示例2：**

<pre>
<strong>输入：</strong>nums = [1,2,3], sequences = [[1,2]]
<strong>输出：</strong>false
<strong>解释：</strong>最短可能的超序列为 [1,2]。
序列 [1,2] 是它的子序列：[1,2]。
因为 nums 不是最短的超序列，所以返回false。
</pre>

**示例3：**

<pre>
<strong>输入：</strong>nums = [1,2,3], sequences = [[1,2],[1,3],[2,3]]
<strong>输出：</strong>true
<strong>解释：</strong>最短可能的超序列为[1,2,3]。
序列 [1,2] 是它的一个子序列：[1,2,3]。
序列 [1,3] 是它的一个子序列：[1,2,3]。
序列 [2,3] 是它的一个子序列：[1,2,3]。
因为 nums 是唯一最短的超序列，所以返回true。
</pre>

**提示：**

- `n == nums.length`
- 1 <= n <= 10<sup>4</sup>
- `nums` 是 `[1, n]` 范围内所有整数的排列
- 1 <= sequences.length <= 10<sup>4</sup>
- 1 <= sequences[i].length <= 10<sup>4</sup>
- 1 <= sum(sequences[i].length) <= 10<sup>5</sup>
- 1 <= sequences[i][j] <= n
- `sequences` 的所有数组都是 **唯一** 的
- `sequences[i]` 是 `nums` 的一个子序列


## Solution

拓扑排序，求是否有一条路径从起点到终点，**入度为0的点只有一个，则一定是一个最短的超序列。**


## Code
```java
class Solution {
    public boolean sequenceReconstruction(int[] nums, int[][] sequences) {
        Map<Integer, Set<Integer>> map = new HashMap<>();
        int[] indegree = new int[nums.length + 1];
        for(int[] sequence: sequences){
            for(int i = 1; i < sequence.length; i++){
                int pre = sequence[i - 1];
                int next = sequence[i];
                if(map.containsKey(pre) && map.get(pre).contains(next)) continue;
                map.putIfAbsent(pre, new HashSet<>());
                map.get(pre).add(next);
                indegree[next] ++;
            }
        }
        Queue<Integer> queue = new ArrayDeque<>();
        for(int i = 1; i < nums.length + 1; i++){
            if(indegree[i] == 0) queue.offer(i);
        }
        while(!queue.isEmpty()){
            if(queue.size() > 1) return false;
            int temp = queue.poll();
            Set<Integer> set = map.getOrDefault(temp, new HashSet<>());
            for(int i: set){
                indegree[i]--;
                if(indegree[i] == 0) queue.offer(i);
            }
        }
    return true;
    }
}
```
