---
title: MySQL知识点汇总
categories: [Backend, MySQL]
tags: []
date: 2022-06-22T13:33:24+800
last_modified_at: 2023-06-06T15:40:38+800
pin: false
---

# B树和B+树

- B树（多路的平衡搜索树），节点可以存储多个数据，并且每个节点存放索引和数据，一个节点的关键字等于该节点子节点个数减一。查询的最好情况是O（1），一般高度为3。
- B+树，非叶子节点关键字个数等于子节点个数
1. 叶子节点保存数据，非叶子节点保存索引，查询固定为O（n），并且由于这个特点更适合外部存储。
2. 叶子节点有指向下一个叶子节点的指针，类似单链表，因此区间访问的性能较好。

## 事务的隔离

MVCC: Read view + undo log + 4个隐藏字段（版本链）
- Read View 用来判断具体哪一个快照是可见的
- undo log是存放更新前的数据（快照），保存了历史快照
- 隐藏字段：trx_list,up_limit_id,low_limit_id,creator_trx_id，和 undo log中的 roll_pointer 回滚指针

MVCC(Multiversion Concurrency Control)的两种读：
1. 快照读，不加锁，在事务中第一次SELECT语句执行时生成，只有在本事务中对数据进行更改才会更新快照。
2. 当前读，加**间隙锁**，（FOR UPDATE）
- 查询条件不走索引，锁住所有间隙，等价于表锁
- 查询条件走普通索引，锁住查询条件附近的间隙
- 查询条件走唯一索引，只锁一条数据，退化成行锁

三种问题：
1. 脏读，指读到其他事务未提交的数据，可能存在回滚
2. 不可重复读，指在同一事务内读到的数据是不一致的
3. 幻读，指事务在查询（SELECT）的过程中，有另外一个事务对范围内**新增了记录**(INSERT)，导致范围查询的结果条数不一致的现象。

SQL的四种隔离级别：
1. 读未提交
2. 读已提交
3. 可重复读
4. 串行化

MVCC + 间隙锁在RR的隔离级别下能解决大部分幻读情况
- MVCC 快照读的情况下，多次查询获取的是同一个快照数据。
- 间隙锁，其他事务的插入操作会被阻塞。
- 解决不了的幻读情况：MVCC只能解决快照读，而对于插入数据后的当前读，更新，删除等操作（不使用快照读），仍然存在幻读的问题。

聚簇索引和非聚簇索引（辅助索引）：

- 聚簇索引：叶子节点是数据节点

- 非聚簇索引：叶子节点是索引节点，需要根据索引上的值（主键）再次回表查询。

建索引的原则：


三大日志binlog, redolog, undolog:
1. Buffer Pool是MySQL进程管理的一块内存空间，有减少磁盘IO次数的作用。
2. redo log重做日志是InnoDB存储引擎的一种物理格式的日志，用来实现事务持久性，主要有两部分文件组成，再内存中的重做日志缓冲（redo log buffer）以及磁盘中的重做日志文件（redo log）。使用场景：**崩溃恢复**，在发生故障的时间点，尚有脏页未写入磁盘，在重启 mysql 服务的时候，根据 redo log 进行重做，从而达到事务的持久性这一特性。
3. undo log回滚日志是InnoDB存储引擎的一种逻辑格式的日志，记录的是数据的逻辑变化，保证的是数据库的**原子性**，比如一条insert语句对应的是一条delete的undo log，在发生事务错误时，就能回滚到事务之前的数据状态。
4. binlog是MySQL Server层的一种逻辑格式的日志，用于记录数据库执行的写入性操作(不包括查询)信息，以二进制的形式保存在磁盘中。使用场景：**主从复制** ：在 Master 端开启 binlog ，然后将 binlog 发送到各个 Slave 端， Slave 端重放 binlog 从而达到主从数据一致。**数据恢复** ：通过使用 mysqlbinlog 工具来恢复数据。

两阶段提交：
- redo log（重做日志）让InnoDB存储引擎拥有了崩溃恢复能力。
- binlog（归档日志）保证了MySQL集群架构的数据一致性。

以基本的事务为单位，redo log在事务执行过程中可以不断写入，而binlog只有在提交事务时才写入，所以redo log与binlog的写入时机不一样。为了解决两份日志之间的逻辑一致问题，将redo log的写入拆成了两个步骤prepare和commit，即两阶段提交。


utf8mb4_unicode_ci 与 utf8mb4_general_ci 的区别：

- 准确性:
  - utf8mb4_unicode_ci 是基于标准的Unicode来排序和比较，能够在各种语言之间精确排序
  - utf8mb4_general_ci 没有实现Unicode排序规则，在遇到某些特殊语言或字符是，排序结果可能不是所期望的。

- 性能:
  - utf8mb4_general_ci 在比较和排序的时候更快
  - utf8mb4_unicode_ci 在特殊情况下，Unicode排序规则为了能够处理特殊字符的情况，实现了略微复杂的排序算法。

## 执行顺序

1. from
2. on
3. join
4. where
5. group by
6. having
7. select
8. distinct
9. order by
10. limit

每一步执行时都会产生一个虚拟表，都会被用作下一个步骤的输入。