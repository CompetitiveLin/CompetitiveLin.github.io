---
title: MySQL知识点汇总
categories: [Backend, MySQL]
tags: []
date: 2022-06-22T13:33:24+800
last_modified_at: 2023-06-06T15:40:38+800
pin: false
---

# B树和B+树

- B树（多路的平衡搜索树），节点可以存储多个数据，并且每个节点存放索引和数据，一个节点的**关键字**等于该节点子节点个数减一。查询的最好情况是O（1），一般高度为3。
- B+树，非叶子节点关键字个数等于子节点个数
1. 叶子节点保存数据，非叶子节点保存索引，查询固定为O（logn），并且由于这个特点更适合外部存储。
2. 叶子节点有指向下一个叶子节点的指针，类似单链表，可顺序访问，因此区间访问的性能较好。
3. 存在重复元素，因为非叶子结点不保存数据。

与红黑树的比较，B+树的优势：
1. 更少的查询次数，因为B+树的树高一般小
2. 利用计算机的预读特性，因为B+树具有类似单链表的特点，因此相邻的节点也能被预先载入

## MySQL索引

### 数据结构维度：
1. B+树索引，适合范围查询，复杂度为O（logn）。
2. 哈希索引，能以O（1）时间进行查找，但失去有序性，无法用于排序和分组，只支持精确查找（等值查找）。
3. 全文索引，使用倒排索引实现，记录关键词到所在文档的映射，一般在text, varchar上创建。
4. R-Trees索引，MyISAM支持的索引类型，和空间地理数据有关。

### 物理存储维度（InnoDB）：
1. 聚簇索引，叶节点存放一整行记录。一个表只能拥有一个聚簇索引。
2. 非聚簇索引（二级索引），叶节点只存放主键信息，所以一般需要回表查询。

### 逻辑维度
1. 主键索引，不允许空值
2. 普通索引，没任何限制
3. 联合索引，多个字段创建的索引，使用时遵循左前缀原则。
4. 唯一索引，索引列中的值必须是唯一的，但可以为空值。
5. 空间索引


### [索引失效？](https://www.51cto.com/article/702691.html)主要看是否回表
1. 不满足最左匹配（但也需要看是否是覆盖索引，例如对于联合索引(col1,col2,col3)，查询语句SELECT col1,col2,col3 FROM test WHERE col2=2;也能够触发索引）
2. 尽可能明确查询列，而不是select *，即使不满足最左匹配（可以用于性能优化）
3. 索引列参与运算
4. 索引列使用函数
5. 错误的like使用(当模糊匹配的占位符位于条件的首部，并且要看数据库中的字段)
6. 类型隐式转换（参数类型和字段类型不匹配，例如 where no = 1，但no实际上是varchar类型的）
7. 错误的or使用（切记两个条件都要添加索引，否则会导致索引失效，or两边同时使用 < 和 >，也会失效）
8. 两列做比较
9. 错误的 <> 和 != 使用（查询结果集占比较大时索引会失效）
10. is not null(is null 走索引)
11. not in(条件列是主键时走索引)
12. not exists 
13. orderby（部分会失效）


### 索引跳跃扫描

最左缀原则可以通过跳跃扫描的方式打破，当第一列索引的唯一值较少时，即使where条件没有第一列索引，查询的时候也可以用到联合索引。

举例：`select * from table1 where b like '3%' and c = 3`

5.6 之前：
- 先通过 联合索引 查询到 开头为 3 的数据 然后拿到主键
- 然后通过主键去主键索引里面去回表查询 二级索引里面查询出来几个 3 开头的就回表几次

5.6 之后：
- 先通过 二级索引 查询到开头为 3 的数据 然后 再找到 c = 3 的数据进行过滤 之后拿到主键
- 通过主键进行回表查询，减少了回表次数



### 哪些情况下不适合建索引
- 数据量少
- 更新频繁
- 区分度低
- where, groupby, orderby 后没有使用到的字段
- 联合索引中的索引


### 索引下推

指将部分上层（服务层）负责的事情，交给了下层（引擎层）去处理。它能减少回表查询次数，提高查询效率。


## 事务的隔离

MVCC: Read view + undo log + 4个隐藏字段（版本链）
- Read View 用来判断具体哪一个快照是可见的
- undo log是存放更新前的数据（快照），保存了历史快照
- 隐藏字段：trx_list,up_limit_id,low_limit_id,creator_trx_id，和 undo log中的 roll_pointer 回滚指针

MVCC(Multiversion Concurrency Control)的两种读：
1. 快照读，不加锁，在事务中第一次SELECT语句执行时生成，只有在本事务中对数据进行更改才会更新快照。
2. 当前读，加**间隙锁**，（FOR UPDATE）
- 查询条件不走索引，锁住所有间隙，等价于表锁
- 查询条件走普通索引，锁住查询条件附近的间隙
- 查询条件走唯一索引，只锁一条数据，退化成行锁

三种问题：
1. 脏读，指读取未提交数据
2. 不可重复读，指在同一事务内读到的数据是不一致的
3. 幻读，指事务在查询的过程中，有另外一个事务对范围内**新增了记录**，导致范围查询的结果条数不一致的现象。

SQL的四种隔离级别：
1. 读未提交，可能出现脏读
2. 读已提交，可能出现不可重复读
3. 可重复读，可能出现幻读，但使用MVCC + 间隙锁能解决大部分幻读现象
4. 串行化

MVCC + 间隙锁在RR的隔离级别下能解决大部分幻读情况
- MVCC 快照读的情况下，多次查询获取的是同一个快照数据。
- 间隙锁，其他事务的插入操作会被阻塞。
- 解决不了的幻读情况：MVCC只能解决快照读，而对于插入数据后的当前读，更新，删除等操作（不使用快照读），仍然存在幻读的问题。

聚簇索引和非聚簇索引（辅助索引）：

- 聚簇索引：叶子节点是数据节点

- 非聚簇索引：叶子节点是索引节点，需要根据索引上的值（主键）再次回表查询。

建索引的原则：




## WAL 机制

WAL(Write-ahead logging)指 MySQL 在执行写操作时先记录在日志中，后更新到磁盘中。

WAL 核心：将随机写（磁盘的写操作是随机IO，耗性能）转变成顺序写和组提交机制，降低客户端延迟，提高吞吐量。

### 三大日志binlog, redolog, undolog:
1. Buffer Pool是MySQL进程管理的一块内存空间，有减少磁盘IO次数的作用。
2. redo log重做日志是InnoDB存储引擎的一种物理格式的日志，用来实现事务持久性，主要有两部分文件组成，再内存中的重做日志缓冲（redo log buffer）以及磁盘中的重做日志文件（redo log），（循环写，数据会被覆盖）。使用场景：**崩溃恢复**，在发生故障的时间点，尚有脏页未写入磁盘，在重启 mysql 服务的时候，根据 redo log 进行重做，从而达到事务的持久性这一特性；**MVCC**，事务未提交前，undo log 保存了未提交的版本数据，作为旧版本的快照数据，类似于做备份。
3. undo log回滚日志是InnoDB存储引擎的一种逻辑格式的日志，记录的是数据的逻辑变化，保证的是数据库的**原子性**，比如一条insert语句对应的是一条delete的undo log，在发生事务错误时，就能回滚到事务之前的数据状态。
4. binlog是MySQL Server层的一种逻辑格式的日志，用于记录数据库执行的写入性操作(不包括查询)信息，以二进制的形式保存在磁盘中。使用场景：**主从复制** ：在 Master 端开启 binlog ，然后将 binlog 发送到各个 Slave 端， Slave 端重放 binlog 从而达到主从数据一致；**数据恢复**，通过使用 mysqlbinlog 工具再结合 binlog 文件，可以将数据恢复到过去的某一时刻。


### 两阶段提交：
- prepare阶段：先将数据修改**写入redo log**，并将其标记为 prepare 状态，将相应的 sql 语句**写入 binlog**。
- commit阶段：将 **redo log 标记为 commit 状态**，然后根据 sync_binlog 参数的设置，决定是否将 binlog 刷盘。

如果发生崩溃，可以根据redo log恢复数据页的状态（让InnoDB存储引擎拥有了崩溃恢复能力），也可以根据 binlog 恢复sql语句的执行（保证了MySQL集群架构的数据一致性）。通过两阶段的流程可以保证任何时刻 redo log 和 binlog 在逻辑上一致。


为什么需要两阶段提交？

- 以基本的事务为单位，redo log 在事务执行过程中可以不断写入，而 binlog 只有在提交事务时才写入，所以redo log 与 binlog 的写入时机不一样。为了解决两份日志之间的逻辑一致问题，将redo log的写入拆成了两个步骤 prepare 和 commit，即两阶段提交。如果只有 redo log 或者只有 binlog，那么事务就不需要两阶段提交。


### utf8mb4_unicode_ci 与 utf8mb4_general_ci 的区别：

- 准确性:
  - utf8mb4_unicode_ci 是基于标准的Unicode来排序和比较，能够在各种语言之间精确排序
  - utf8mb4_general_ci 没有实现Unicode排序规则，在遇到某些特殊语言或字符是，排序结果可能不是所期望的。

- 性能:
  - utf8mb4_general_ci 在比较和排序的时候更快
  - utf8mb4_unicode_ci 在特殊情况下，Unicode排序规则为了能够处理特殊字符的情况，实现了略微复杂的排序算法。

## 执行顺序

1. from
2. on
3. join
4. where
5. group by
6. having
7. select
8. distinct
9. order by
10. limit

每一步执行时都会产生一个虚拟表，都会被用作下一个步骤的输入。