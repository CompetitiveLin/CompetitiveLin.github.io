---
title: Basics of Java
categories: [Backend, Java]
tags: [java, backend]
date: 2022-06-21T14:23:14+800
last_modified_at: 2023-05-07T23:54:58+800
pin: true
---

# 基本知识

语法糖：switch支持String、泛型、自动拆装箱、变长参数、枚举、内部类、条件编译、断言、数值下划线、for-each、try-with-resources、Lambda表达式

装箱：`Integer i = Integer.valueOf(10)`， 拆箱：`int n = i.intValue()`

类的生命周期：
- 加载：通过类的全限定名（包名 + 类名）获取class文件的二进制字节流（通过类加载器来完成，其加载过程使用[**双亲委派模型**](https://www.51cto.com/article/647617.html)），将其转化为方法区运行时的数据结构，最后在堆中实例化一个java.lang.Class对象，作为方法区中这个类的信息的入口。
- 连接
  - 验证：验证字节流包含的信息是否符合当前虚拟机的要求。
  - 准备：为类的**静态变量**分配内存并设为jvm的**默认值**（不同于下文的初值，基本类型为零，引用类型为null，final修饰的常量为设定的值），对于非静态的变量，则不会为它们分配内存。
  - 解析：虚拟机将常量池中的符号引用替换为直接引用，主要针对类或接口，字段，类方法，方法类型等。举例：通过身份证号（符号引用）查找地址（直接引用），使用内存地址（直接引用）指向方法名（符号引用）代替方法名。
- 初始化：按照顺序自上而下运行类中的变量赋值语句和静态语句，如果有父类，则首先按照顺序运行父类中的变量赋值语句和静态语句在类的初始化阶段，只会初始化与类相关的静态赋值语句和静态语句。类变量（静态变量）在方法区分配内存，并设置**初值**。
- 使用：包括主动引用和被动引用。
- 卸载：需要同时满足以下三个条件：该类所有的实例都已经被回收，即Java堆中不存在该类的任何实例；加载该类的ClassLoader已经被回收；该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。[单例对象不会被JVM垃圾回收](https://blog.csdn.net/zhengzhb/article/details/7331354)，因为无法满足卸载的第一个条件，Java堆中会始终存在该单例的实例。

线程上下文类加载器：破坏了“双亲委派模型”，可以在执行线程中抛弃双亲委派加载链模式，使程序可以逆向使用类加载器，例如SPI (Service Provider Interface)。SPI**接口**中的代码经常需要加载具体的**实现类**。SPI接口是Java核心库的一部分，由**启动类加载器(Bootstrap Classloader)**来加载，而实现类由**系统类加载器(AppClassLoader)**来加载。

![](https://raw.githubusercontent.com/CompetitiveLin/ImageHostingService/picgo/imgs/202305071548284.png)

Tomcat中的类加载器：

- Tomcat自身所使用的类加载器，会加载jre的lib包及tomcat的lib包的类，遵循双亲委派机制。加载顺序：(1).先从缓存中加载；(2).如果没有，则从JVM的Bootstrap类加载器加载；(3).如果没有，则从父类加载器加载，加载顺序是AppClassLoader、Common、Shared。(4).如果没有，则从当前类加载器加载（按照WEB-INF/classes、WEB-INF/lib的顺序）；
- 每个Web应用程序用的，每个web应用程序都有自己专用的WebappClassLoader，优先加载/web-inf/lib下的jar中的class文件，这样就隔离了每个web应用程序的影响，不遵循双亲委派机制。加载顺序：(1).先从缓存中加载；(2).如果没有，则从JVM的Bootstrap类加载器加载；(3).如果没有，则从当前类加载器加载（按照WEB-INF/classes、WEB-INF/lib的顺序）；(4).如果没有，则从父类加载器加载，由于父类加载器采用默认的委派模式，所以加载顺序是AppClassLoader、Common、Shared。

Java的SPI：当服务的提供者提供了服务接口的一种实现之后，在jar包的META-INF/services/目录里同时创建一个以服务接口命名的文件。该文件里就是实现该服务接口的具体实现类。而当外部程序装配这个模块的时候，就能通过该jar包META-INF/services/里的配置文件找到具体的实现类名，并装载实例化，完成模块的注入。


运行时数据区域包含线程共享的方法区、堆、直接内存（非运行时数据区的一部分）和线程私有的程序计数器、虚拟机栈、本地方法栈。
- 程序计数器：与操作系统中的程序计数器类似，为了线程切换后能恢复到正确的执行位置，是唯一一个不会出现 `OutOfMemoryError` 的内存区域。
- 虚拟机栈：以帧为单位，帧由局部变量表、操作数栈、动态链接、方法返回地址组成。每一次方法调用都会有一个对应的栈帧被压入栈中，每一个方法调用结束后，都会有一个栈帧被弹出。
  - 局部变量表：主要存放了编译期可知的各种数据类型（boolean、byte、char、short、int、float、long、double）、**对象引用**（reference 类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）
  - 操作数栈：用于存放方法执行过程中产生的中间计算结果，也存放计算过程中产生的临时变量。
  - 动态链接：将常量池中指向方法的符号引用转化为其在内存地址中的直接引用。与类加载中的解析类似。
  - 方法返回地址：顾名思义。
- 本地方法栈：和虚拟机栈所发挥的作用非常相似，区别是：虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而**本地方法栈则为虚拟机使用到的 Native 方法（机器码）服务**。

- 堆：唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。

[class常量池、字符串常量池和运行时常量池的区别](https://blog.csdn.net/xiaojin21cen/article/details/105300521)：

- 字符串常量池：简单理解为用C++实现的默认固定大小为1009的HashTable。在每个VM中只有一份，存放的是字符 串常量的 引用值 。关于常量池中的String类型的数据，在JDK6中只可能是对象，在JDK7中[既可以是对象也可以是引用](https://tech.meituan.com/2014/03/06/in-depth-understanding-string-intern.html)。
- 类常量池：每个java文件被编译成class文件后会有一项常量池，用于存放编译器生成的**字面量**和**符号引用**。在**编译**阶段，存放的是常量的**符号引用**。
- 运行时常量池：是在**类加载完成后**，将每个class常量池中的符号引用值转存到 运行时常量池 中，也就是说，每个class都有一个 运行时常量池 ，类在 解析阶段 ，将 符号引用 替换成 直接引用 ，与 字符串常量池 中的引用值保持一致。

1.6 -> 1.7 -> 1.8:
- 1.6 -> 1.7: 字符串常量池从方法区（永久代）中移到堆中。原因： GC 回收效率太低，只有在整堆收集 (Full GC)的时候才会被执行 GC。Java 程序中通常会有大量的被创建的字符串等待回收。
- 1.7 -> 1.8: 将运行时数据区方法区（永久代）移动到直接内存中，字符串常量池仍然在堆中。


对象的创建过程：
1. 类加载检查
2. 分配内存：指针碰撞或空闲列表
3. 初始化零值
4. 设置对象头
5. 执行init方法

对象的内存布局：
1. 对象头，两部分组成：存储自身运行时数据如哈希码，GC分代年龄；指向类的类型指针
2. 实例数据，真正存储有效信息的部分
3. 对齐填充，起占位作用

[对象的定位访问（针对JVM虚拟机栈中的局部变量表）](https://javaguide.cn/java/jvm/memory-area.html#%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D)：
1. 句柄，Java 堆中将会划分出一块内存来作为句柄池，局部变量表 reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与对象类型数据各自的具体地址信息。
2. 直接指针，局部变量表里 reference 中存储的直接就是对象的地址。


内存分配和回收原则：
- 对象优先在Eden区分配
- 大对象直接进入老年代
- 长期存活的进入老年代

GC 分类：
- Partial GC
  - Minor GC：只对新生代进行垃圾收集
  - Major GC：只对老年代进行垃圾收集
  - Mixed GC：整个新生代和部分老年代
- Full GC：整个Java堆和方法区

垃圾收集器发展历程：
1. Serial（串行），单线程垃圾收集
2. Parallel（并行），多线程垃圾收集
3. CMS（并发），在Minor GC时会暂停所有的应用线程，并以多线程的方式进行垃圾回收。在Full GC时不再暂停应用线程，而是使用若干个后台线程定期的对老年代空间进行扫描，及时回收其中不再使用的对象。
4. G1（并发），内存碎片的产生率大大降低。

![](https://raw.githubusercontent.com/CompetitiveLin/ImageHostingService/picgo/imgs/202305091408302.png)
_G1收集器内存模型_

GC Roots：JVM的标记算法是通过可达性算法寻找活跃对象，而GC Roots正是可达性算法的根节点。

哪些对象可以作为GC Roots？
- 虚拟机栈(栈帧中的本地变量表)中引用的对象
- 本地方法栈(Native 方法)中引用的对象
- 方法区中类静态属性引用的对象
- 方法区中常量引用的对象
- 所有被同步锁持有的对象

垃圾收集算法：
- 标记——清除算法：顾名思义，标记可回收的对象并清除。
- 标记——复制算法：将内存分成大小相同的两份，需要垃圾收集时，将存活的对象复制到另一份内存中，缺点：内存缩小为原来的一半。
- 标记——整理算法：标记可回收的对象，将存活的对象向一端移动，适合老年代这种垃圾回收频率不高的场景。
- 分代收集算法：在新生代和老年代不同的代用不同的垃圾收集算法。


Garbage First（G1）收集器：
- 特点：引入**分区**的思路，弱化了分代的概念，并合理利用垃圾收集各个周期的资源。
- 内存结构：堆内存被切分为多个固定大小的区域，最小为1M，最大为32M，默认2048份。
- 内存分配：每个区域被标记为E、S、O和H，分别表示Eden，Survivor，Old，Humongous。Humongous区域是为了那些存储超过50%标准region大小的对象而设计的，它用来专门存放巨型对象。如果一个H区装不下一个巨型对象，那么G1会寻找连续的H分区来存储。为了能找到连续的H区，有时候不得不启动Full GC。
- 执行特点：
  - 并行与并发：使用多个CPU核缩短Stop The World停顿时间。
  - 空间整合：从整体来看是基于“标记-整理”算法实现的收集器；从局部上来看是基于“标记-复制”算法实现的。
  - 可观测的停顿：能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在垃圾收集上的时间不得超过 N 毫秒。
  - G1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region(这也就是它的名字 Garbage-First 的由来) 。
- 步骤：
  1. 初始标记
  2. 并发标记
  3. 最终标记
  4. 筛选回收
  
![](https://raw.githubusercontent.com/CompetitiveLin/ImageHostingService/picgo/imgs/202305091525435.png)


[JVM调优](https://cloud.tencent.com/developer/beta/article/1812722)：
1. 选择合适的垃圾收集器：CPU单核，只能选择Serial；CPU多核，关注吞吐量 ，那么选择[Parallel Scavenge（标记复制） + Paralle Old（标记整理）](https://juejin.cn/post/6986571159902879751)组合；CPU多核，关注用户停顿时间，JDK版本1.6或者1.7，那么选择CMS。CPU多核，关注用户停顿时间，JDK1.8及以上，JVM可用内存6G以上，那么选择G1。
2. 调整内存大小，现象：垃圾收集频率非常频繁。
3. 设置符合预期的停顿时间，现象：程序间接性的卡顿。参数：`-XX:MaxGCPauseMillis`
4. 调整内存区域大小比率，现象：某一个区域的GC频繁，其他都正常。参数：`-XX:SurvivorRatio=6, -XX:NewRatio=4`
5. 提升老年代年龄标准，现象：老年代频繁GC，每次回收的对象很多。参数：`-XX:InitialTenuringThreshol=7`
6. 调整大对象的标准，现象：老年代频繁GC，每次回收的对象很多，而且单个对象的体积都比较大。参数：`-XX:PretenureSizeThreshold=1000000//新生代可容纳的最大对象,大于则直接会分配到老年代，0代表没有限制。`
7. 调整GC的触发时机，现象：CMS收集器的情况下，G1 经常 Full GC，程序卡顿严重。
8. 调整JVM本地内存（直接内存）大小，现象：堆内存空间充足，但是报OOM

调优的一条经验总结：
>将新对象预留在新生代，由于 Full GC 的成本远高于 Minor GC，因此尽可能将对象分配在新生代是明智的做法，实际项目中根据 GC 日志分析新生代空间大小分配是否合理，适当通过“-Xmn”命令调节新生代大小，最大限度降低新对象直接进入老年代的情况。

![](https://raw.githubusercontent.com/CompetitiveLin/ImageHostingService/picgo/imgs/202305111608659.png)

Java IO:
- 阻塞/非阻塞，如果方法不能立即返回，需要等待，线程会阻塞
- 同步/异步，如果能开启新的线程，则叫异步，多线程是实现异步的一种方式。

NIO vs IO:
- IO是面向流的，NIO是面向缓冲区的
- IO流是阻塞的，NIO流是不阻塞的
- 选择器：Java NIO的选择器允许一个单独的线程来监视多个输入通道

IO多路复用（事件驱动）：**一个线程不断轮询多个socket的状态**，只有当socket真正有读写状态时，借用当前线程或者使用线程池额外启动线程，调用实际的IO读写操作。

Java NIO: 
- 实际上也是一种多路复用的IO。
- 三大核心部分：Channel(通道) ，Buffer(缓冲区), Selector(选择器)，Channel 负责传输， Buffer 负责存取数据
  - Channel是双向的，数据总是从通道读到缓冲区或者从缓冲区中写入通道内。
- 额外一个Selector线程，用于监听多个通道（Channel）的事件（比如：连接打开，数据到达），如果由事件发生，则获取事件并对每个事件进行相应的响应处理。





并发编程：一个 Java 程序的运行是 main 线程和多个其他线程同时运行。


多线程：
- run()，调用普通方法，并不开启新线程。
- start()，启动新线程，由JVM调用线程的run()方法。

集合框架：
- Collection
  - Set
  - List
  - Queue
- Map

线程安全的list：
- vector
- CopyOnWriteArrayList 读多写少的情况
- Collections.synchronizedList() 读少写多的情况

HashMap:
- HashMap: 乱序，数组+链表+红黑树，链表长度大于8转红黑树，红黑树节点个数小于6转链表。
- LinkedHashMap: 按插入顺序排序
- TreeMap: 按字典序排序，因为是按字典序排序的，所以键肯定不能为null，值可以为null
- IdentityHashMap：利用哈希表实现Map接口，不同的是，其比较键（或值）时，使用引用相等性代替对象相等性。
- ConcurrentSkipListMap：基于跳表的线程安全的，实现快速查找的链表结构。

Set:
- HashSet: 乱序，基于HashMap实现
- LinkedHashSet: 按插入的顺序排序，基于LinkedHashMap实现
- TreeSet: 按字典序排序，基于红黑树


NULL key AND NULL value:
- key
  - HashMap、LinkedHashMap、IdentityHashMap 能使用 null key
  - ConcurrentHashMap、ConcurrentSkipListMap、TreeMap、HashTable 不能使用 null key。
- value
  - HashMap、LinkedHashMap、TreeMap、IdentityHashMap 能使用 null value
  - Hashtable、ConcurrentHashMap、ConcurrentSkipListMap 不能使用 null value。


ConcurrentHashMap JDK7 vs JDK8
- JDK7: 数组 + 链表。先定位 Segment，再定位桶。底层结构是继承了ReentrantLock的Segment数组。可以看成是由线程安全的HashMap组成的一个map数组，数组的长度决定了支持的最大的并发量。
- JDK8: 数组 + 链表 + 红黑树。可以直接定位到桶。链表中的元素超过8后，将链表结构转换成红黑树。通过对Node数组以CAS方式实现扩容和对Node数组的每个元素的synchronized保证ConcurrentHashMap整体的线程安全。

![](https://raw.githubusercontent.com/CompetitiveLin/ImageHostingService/picgo/imgs/202305151605481.png)

HashTable速度慢：使用synchronized对整个对象加锁。

JDK7：**对整个数组进行分段**(每段都是由若干个 hashEntry 对象组成的链表)，每个分段都有一个 Segment 分段锁(继承 ReentrantLock 分段锁)。与hashtable相比，加锁粒度更细，但是初始化Segment数组长度后就无法扩容。ConcurrentHashMap 是一个二级哈希表。在一个总的哈希表下面，有若干个子哈希表。

![](https://raw.githubusercontent.com/CompetitiveLin/ImageHostingService/picgo/imgs/202305161016705.png)

JDK8：对table数组的头节点加锁
- put：分两步，计算哈希值和一个死循环，循环步骤，
  1. first节点还没有初始化，所以初始化first节点，然后进入下次循环；
  2. first节点初始化了,但是为空，**采用CAS方式把当前要put的值设置进这处，设置失败则进入下次循环，成功则保存成功，退出循环；**
  3. 如果判断有其他线程正在对ConcurrentHashMap扩容（hash==MOVED），获取要去获取新的tab，进入下次循环；
  4. 找到了对应节点f，直接**对f加synchronized同步**，然后判断f节点是链表结构还是红黑树结构，链表结构则遍历链表进行设置，红黑树则采用红黑树设置进去。设置成功后判断是否需要把链表结构转红黑树；


ThreadLocal:将数据封闭在线程中而避免使用同步，即线程封闭。线程局部变量，不会因为其他线程改变同个变量的值而使该线程中的变量发生变化。一个ThreadLocal对象即是一个线程局部变量。jdbc连接池就是用ThreadLocal，典型例子。以下使四种方法：
- Object get()：获取该线程局部变量的值。
- void set(Object value)：给该线程局部变量赋值。
- protected Object initialValue()：返回该线程局部变量的初始值，该方法是一个protected的方法，
显然是为了让子类覆盖而设计的。
- public void remove()：将当前线程局部变量的值删除。

正确使用方法：
- 每次使用完ThreadLocal都调用它的remove()方法清除数据
- 将ThreadLocal变量定义成private static，这样就一直存在ThreadLocal的强引用，也就能保证任何时候都能通过ThreadLocal的弱引用访问到Entry的value值，进而清除掉。


JDK四种线程池：
- newCachedThreadPool，可根据需要创建新线程的线程池
- newSingleThreadExecutor，单线程池
- newFixedThreadPool，创建固定大小的线程池
- newScheduledThreadPool，创建一个大小无限的线程池

线程池执行顺序：
1. 首先判断核心的线程数是否已满，如果没有满，那么就去创建一个线程去执行该任务；否则请看下一步
2. 如果线程池的核心线程数已满，那么就继续判断任务队列是否已满，如果没满，那么就将任务放到任务队列中；否则请看下一步
3. 如果任务队列已满，那么就判断线程池是否已满，如果没满，那么就创建线程去执行该任务；否则请看下一步；
4. 如果线程池已满，那么就根据拒绝策略来做出相应的处理；

![](https://raw.githubusercontent.com/CompetitiveLin/ImageHostingService/picgo/imgs/202305171352348.png)


四种拒绝策略：
1. AbortPolicy 拒绝任务并抛出一个异常 RejectedExecutionException
2. DiscardPolicy 拒绝任务，不抛出异常。
3. DiscardOldestPolicy 把老的任务丢掉，执行新任务。
4. CallerRunsPolicy 直接调用线程处理该任务，

线程池被回收：线程池也是在堆中也是一个对象，一定要调用shutdown

线程池何时回收线程：getTask()的返回值为null时
1. 未调用shutdown()，并且当前工作线程数过多
2. 调用shutdown()，缓冲队列中的线程为空



锁：
1. 乐观锁，悲观锁：
  - 乐观锁，修改数据前比较数据是否被修改过。CAS，原子类的递增操作，适合频繁读
  - 悲观锁，加锁使其他线程无法修改。synchronized和lock的实现类，适合频繁写
2. 自旋锁，非自旋锁：获取同步资源的锁失败，资源被占用（上下文切换，也就是线程的唤醒和阻塞是十分耗时的）
- 自旋锁，不放弃CPU时间片，通过自旋等待锁的释放，但自旋超过一定次数（默认10次）仍没有获得锁，那么线程被挂起。线程竞争不激烈并且锁持有的时间不长时，可以使用自旋锁。
- 非自旋锁，线程会进入阻塞状态

3. 无锁，偏向锁，轻量级锁，重量级锁：指针对synchronized同步锁的状态，锁可以升级但不能降级。
- 偏向锁，通过对比Mark Word中是否存储着指向当前线程的偏向锁以解决加锁问题，避免执行CAS操作来加锁和解锁，Java15放弃偏向锁。使用背景：锁不仅不存在多线程竞争，而且总是由同一个线程多次获取，那么在同一个线程反复获取所释放锁中，其中并还没有锁的竞争。
- 轻量级锁，通过用CAS修改Mark Word操作和**自旋**来解决加锁问题，避免线程阻塞和唤醒而影响性能。
- 重量级锁，将除了拥有锁的线程以外的线程都阻塞。

4. 公平锁，非公平锁：
- 公平锁，多个线程按照申请锁的顺序获取锁
- 非公平锁，多个线程加锁时直接尝试获取锁，获取不到才会到等待队列的队尾等待。但如果此时锁刚好可用，那么这个线程可以无需阻塞直接获取到锁。

5. 可重入锁（递归锁），非可重入锁：ReentrantLock和synchronized都是可重入锁，**NonReentrantLock是非可重入锁**
- 可重入锁，指在同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁（前提锁对象得是同一个对象或者class），不会因为之前已经获取过还没释放而阻塞。好处是一定程度避免死锁。
- 非可重入锁，如果一个方法中获取锁并调用另外方法，那么在调用另外方法前需要释放锁。

6. 独享锁（排它锁），共享锁
- 独享锁，ReentrantLock、synchronized、ReentrantReadWriteLock的写锁
- 共享锁，ReentrantReadWriteLock的读锁

Synchronized（同步锁）：属于独占锁、悲观锁、可重入锁、非公平锁。

ReentrantLock：继承了Lock类，两者都是可重入锁、悲观锁、独占锁、默认非公平锁。

AbstractQueuedSynchronizer（AQS）简单解释：CAS修改volatile修饰的int值 + 一个存放等待锁的线程队列

volatile关键字：
- 保证可见性，但不保证原子性！只是确保将变量的更新操作通知到其他线程。
- 不保证原子性！！
- 禁止指令重排，背景：为了提高性能，编译器和处理器常常会对指令重排。禁止指令重排避免了多线程环境下程序出现乱序执行的现象。

Spring核心之控制反转（IOC）和依赖注入（DI）：
- IOC是一种设计思想，将设计好的Bean对象交给容器控制，而不是在传统的在对象内部直接控制。用@Configutation + @Bean的方式
- DI是一种实现方式，将应用程序依赖的对象注入到容器中。


Contract接口模式，结合feign实现
- contract 用于暴露接口
- service 用于实现接口


Spring创建Bean的三步（由反射创建的）：
- 实例化，`AbstractAutowireCapableBeanFactory` 的 `createBeanInstance` 方法
- 属性注入，`AbstractAutowireCapableBeanFactory` 的 `populateBean` 方法
- 初始化，`AbstractAutowireCapableBeanFactory` 的 `initializeBean` 方法

Spring启动时先扫描所有Bean信息，BeanDefinition存储日常给Spring Bean定义的元数据。然后存储BeanDefinition的BeanDefinitionMap，是根据字典序依次创建Bean对象。

[三级缓存解决循环依赖](https://developer.aliyun.com/article/766880)：
- 前提，出现循环依赖的Bean必须是单例；依赖注入的方式不能全是构造器注入（全是构造器注入则无法解决循环依赖）。
- getSingleton(beanName)方法三级缓存
  1. singletonObjects，一级缓存，存储的是所有创建好了的**单例Bean对象**
  2. earlySingletonObjects，二级缓存，完成实例化，但是还未进行属性注入及初始化的**提前暴露的对象**
  3. singletonFactories，三级缓存，存放**生产对象的工厂**，并且每次从这个工厂中拿到的对象都是不一样的，二级缓存中存储的就是从这个工厂中获取到的对象，如果Bean存在AOP的话，返回的是AOP的**代理对象**，提前进行了代理，避免对后面重复创建代理对象。

![](https://raw.githubusercontent.com/CompetitiveLin/ImageHostingService/picgo/imgs/202305231628567.png)


为什么需要二级缓存：
如果出现循环依赖+aop时，多个地方注入这个动态代理对象需要保证都是同一个对象。如果只使用这两层缓存，在使用三级缓存中的工厂对象生成的动态代理对象都是新创建的，循环依赖的时候，注入到别的bean里面去的那个动态代理对象和最终这个bean在初始化后自己创建的bean地址值不一样。如果 Spring 选择二级缓存来解决循环依赖的话，那么就意味着所有 Bean 都需要在实例化完成之后就立马为其创建代理，而 Spring 的设计原则是在 Bean 初始化完成之后才为其创建代理。所以，Spring 选择了三级缓存。但是因为循环依赖的出现，导致了 Spring 不得不提前去创建代理，因为如果不提前创建代理对象，那么注入的就是原始对象，这样就会产生错误。


Prototype（原型）对象和单例对象的区别：
- 单例对象在Spring加载的时候就创建，创建完毕后放入一级缓存中
- 而原型对象在每次在需要的时候都会创建，并且也不会存入缓存中
- 单例Bean对象的劣势：线程不安全。解决方案：考虑ThreadLocal

为什么Springboot默认创建单例Bean：
- 不需要多次创建实例
- 减少垃圾回收
- 缓存中可以快速获得



接口和抽象类的区别：

- 相同点：
  - 都不能被实例化
  - 接口的实现类或抽象类的子类都只有实现了接口或抽象类中的方法后才能实例化

- 不同点：
  - 接口只有定义，不能有方法的实现，java 1.8中可以定义default方法体，而抽象类可以有定义与实现，方法可在抽象类中实现。
  - 实现接口的关键字为implements，继承抽象类的关键字为extends。一个类可以实现多个接口，但一个类只能继承一个抽象类。所以，使用接口可以间接地实现多重继承。
  - 接口强调特定功能的实现，而抽象类强调所属关系。
  - 接口成员变量默认为public static final，必须赋初值，不能被修改；其所有的成员方法都是public、abstract的。抽象类中成员变量默认default，可在子类中被重新定义，也可被重新赋值；抽象方法被abstract修饰，不能被private、static、synchronized和native等修饰，必须以分号结尾，不带花括号。


## static修饰词

静态常量/静态变量/静态方法是用static修饰的常量/变量/方法，其**从属于类**。另外，static是不允许用来修饰局部变量的。

- 静态方法可以调用静态变量，但不能调用非静态变量，因为静态方法在类加载时就分配了内存，而非静态变量是在对象实例化时才分配内存。

- 非静态方法可以调用静态变量，也可以调用非静态变量。

### 静态初始化块、初始化块和构造方法的区别

执行顺序：静态初始化块 > 初始化块 > 构造方法

**非静态初始化块（构造代码块）：**

作用：给对象进行初始化。对象一建立就运行，且优先于构造函数的运行。

*与构造函数的区别：*

非静态初始化块给所有对象进行统一初始化，构造函数只给对应对象初始化。

应用：将所有构造函数共性的东西定义在构造代码块中。

**静态初始化块：**

作用：给类进行初始化。随着类的加载而执行，且只执行一次

*与构造代码块的区别：*

- 构造代码块用于初始化对象，每创建一个对象就会被执行一次；静态代码块用于初始化类，随着类的加载而执行，不管创建几个对象，都只执行一次。
- 静态代码块优先于构造代码块的执行
- 都定义在类中，一个带static关键字，一个不带static



# K8s

Kubernetes主要由以下几个核心组件组成：

- etcd保存了整个集群的状态；
- apiserver提供了资源操作的唯一入口，并提供认证、授权、访问控制、API注册和发现等机制；
- controller manager负责维护集群的状态，比如故障检测、自动扩展、滚动更新等；
- scheduler负责资源的调度，按照预定的调度策略将Pod调度到相应的机器上；
- kubelet负责维持容器的生命周期，同时也负责Volume（CVI）和网络（CNI）的管理；
- Container runtime负责镜像管理以及Pod和容器的真正运行（CRI）；
- kube-proxy负责为Service提供cluster内部的服务发现和负载均衡；

除了核心组件，还有一些推荐的add-ons（扩展）：

- kube-dns负责为整个集群提供DNS服务
- Ingress Controller为服务提供外网入口
- Heapster提供资源监控
- Dashboard提供GUI
- Federation提供跨可用区的集群
- Fluentd-elasticsearch提供集群日志采集、存储与查询