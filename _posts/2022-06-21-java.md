---
title: Basics of Java
categories: [Backend, Java]
tags: [java, backend]
date: 2022-06-21T14:23:14+800
last_modified_at: 2023-05-07T23:54:58+800
pin: true
---

# 基本知识

语法糖：switch支持String、泛型、自动拆装箱、变长参数、枚举、内部类、条件编译、断言、数值下划线、for-each、try-with-resources、Lambda表达式

装箱：`Integer i = Integer.valueOf(10)`， 拆箱：`int n = i.intValue()`

类的生命周期：
- 加载：通过类的全限定名（包名 + 类名）获取class文件的二进制字节流（通过类加载器来完成，其加载过程使用[**双亲委派模型**](https://www.51cto.com/article/647617.html)），将其转化为方法区运行时的数据结构，最后在堆中实例化一个java.lang.Class对象，作为方法区中这个类的信息的入口。
- 连接
  - 验证：验证字节流包含的信息是否符合当前虚拟机的要求。
  - 准备：为类的**静态变量**分配内存并设为jvm的**默认值**（不同于下文的初值，基本类型为零，引用类型为null，final修饰的常量为设定的值），对于非静态的变量，则不会为它们分配内存。
  - 解析：虚拟机将常量池中的符号引用替换为直接引用，主要针对类或接口，字段，类方法，方法类型等。举例：通过身份证号（符号引用）查找地址（直接引用），使用内存地址（直接引用）指向方法名（符号引用）代替方法名。
- 初始化：按照顺序自上而下运行类中的变量赋值语句和静态语句，如果有父类，则首先按照顺序运行父类中的变量赋值语句和静态语句在类的初始化阶段，只会初始化与类相关的静态赋值语句和静态语句。类变量（静态变量）在方法区分配内存，并设置**初值**。
- 使用：包括主动引用和被动引用。
- 卸载：需要同时满足以下三个条件：该类所有的实例都已经被回收，即Java堆中不存在该类的任何实例；加载该类的ClassLoader已经被回收；该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。[单例对象不会被JVM垃圾回收](https://blog.csdn.net/zhengzhb/article/details/7331354)，因为无法满足卸载的第一个条件，Java堆中会始终存在该单例的实例。

线程上下文类加载器：破坏了“双亲委派模型”，可以在执行线程中抛弃双亲委派加载链模式，使程序可以逆向使用类加载器，例如SPI (Service Provider Interface)。SPI**接口**中的代码经常需要加载具体的**实现类**。SPI接口是Java核心库的一部分，由**启动类加载器(Bootstrap Classloader)**来加载，而实现类由**系统类加载器(AppClassLoader)**来加载。

![](https://raw.githubusercontent.com/CompetitiveLin/ImageHostingService/picgo/imgs/202305071548284.png)

Tomcat中的类加载器：

- Tomcat自身所使用的类加载器，会加载jre的lib包及tomcat的lib包的类，遵循双亲委派机制。加载顺序：(1).先从缓存中加载；(2).如果没有，则从JVM的Bootstrap类加载器加载；(3).如果没有，则从父类加载器加载，加载顺序是AppClassLoader、Common、Shared。(4).如果没有，则从当前类加载器加载（按照WEB-INF/classes、WEB-INF/lib的顺序）；
- 每个Web应用程序用的，每个web应用程序都有自己专用的WebappClassLoader，优先加载/web-inf/lib下的jar中的class文件，这样就隔离了每个web应用程序的影响，不遵循双亲委派机制。加载顺序：(1).先从缓存中加载；(2).如果没有，则从JVM的Bootstrap类加载器加载；(3).如果没有，则从当前类加载器加载（按照WEB-INF/classes、WEB-INF/lib的顺序）；(4).如果没有，则从父类加载器加载，由于父类加载器采用默认的委派模式，所以加载顺序是AppClassLoader、Common、Shared。

Java的SPI：当服务的提供者提供了服务接口的一种实现之后，在jar包的META-INF/services/目录里同时创建一个以服务接口命名的文件。该文件里就是实现该服务接口的具体实现类。而当外部程序装配这个模块的时候，就能通过该jar包META-INF/services/里的配置文件找到具体的实现类名，并装载实例化，完成模块的注入。


运行时数据区域包含线程共享的方法区、堆、直接内存（非运行时数据区的一部分）和线程私有的程序计数器、虚拟机栈、本地方法栈。
- 程序计数器：与操作系统中的程序计数器类似，为了线程切换后能恢复到正确的执行位置，是唯一一个不会出现 `OutOfMemoryError` 的内存区域。
- 虚拟机栈：以帧为单位，帧由局部变量表、操作数栈、动态链接、方法返回地址组成。每一次方法调用都会有一个对应的栈帧被压入栈中，每一个方法调用结束后，都会有一个栈帧被弹出。
  - 局部变量表：主要存放了编译期可知的各种数据类型（boolean、byte、char、short、int、float、long、double）、**对象引用**（reference 类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）
  - 操作数栈：用于存放方法执行过程中产生的中间计算结果，也存放计算过程中产生的临时变量。
  - 动态链接：将常量池中指向方法的符号引用转化为其在内存地址中的直接引用。与类加载中的解析类似。
  - 方法返回地址：顾名思义。
- 本地方法栈：和虚拟机栈所发挥的作用非常相似，区别是：虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而**本地方法栈则为虚拟机使用到的 Native 方法（机器码）服务**。

- 堆：唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。

[class常量池、字符串常量池和运行时常量池的区别](https://blog.csdn.net/xiaojin21cen/article/details/105300521)：

- 字符串常量池：简单理解为用C++实现的默认固定大小为1009的HashTable。在每个VM中只有一份，存放的是字符 串常量的 引用值 。关于常量池中的String类型的数据，在JDK6中只可能是对象，在JDK7中[既可以是对象也可以是引用](https://tech.meituan.com/2014/03/06/in-depth-understanding-string-intern.html)。
- 类常量池：每个java文件被编译成class文件后会有一项常量池，用于存放编译器生成的**字面量**和**符号引用**。在**编译**阶段，存放的是常量的**符号引用**。
- 运行时常量池：是在**类加载完成后**，将每个class常量池中的符号引用值转存到 运行时常量池 中，也就是说，每个class都有一个 运行时常量池 ，类在 解析阶段 ，将 符号引用 替换成 直接引用 ，与 字符串常量池 中的引用值保持一致。

1.6 -> 1.7 -> 1.8:
- 1.6 -> 1.7: 字符串常量池从方法区（永久代）中移到堆中。原因： GC 回收效率太低，只有在整堆收集 (Full GC)的时候才会被执行 GC。Java 程序中通常会有大量的被创建的字符串等待回收。
- 1.7 -> 1.8: 将运行时数据区方法区（永久代）移动到直接内存中，字符串常量池仍然在堆中。


对象的创建过程：
1. 类加载检查
2. 分配内存：指针碰撞或空闲列表
3. 初始化零值
4. 设置对象头
5. 执行init方法

对象的内存布局：
1. 对象头，两部分组成：存储自身运行时数据如哈希码，GC分代年龄；指向类的类型指针
2. 实例数据，真正存储有效信息的部分
3. 对齐填充，起占位作用

[对象的定位访问（针对JVM虚拟机栈中的局部变量表）](https://javaguide.cn/java/jvm/memory-area.html#%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D)：
1. 句柄，Java 堆中将会划分出一块内存来作为句柄池，局部变量表 reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与对象类型数据各自的具体地址信息。
2. 直接指针，局部变量表里 reference 中存储的直接就是对象的地址。


内存分配和回收原则：
- 对象优先在Eden区分配
- 大对象直接进入老年代
- 长期存活的进入老年代

GC 分类：
- Partial GC
  - Minor GC：只对新生代进行垃圾收集
  - Major GC：只对老年代进行垃圾收集
  - Mixed GC：整个新生代和部分老年代
- Full GC：整个Java堆和方法区

垃圾收集器发展历程：
1. Serial（串行），单线程垃圾收集
2. Parallel（并行），多线程垃圾收集
3. CMS（并发），在Minor GC时会暂停所有的应用线程，并以多线程的方式进行垃圾回收。在Full GC时不再暂停应用线程，而是使用若干个后台线程定期的对老年代空间进行扫描，及时回收其中不再使用的对象。
4. G1（并发），内存碎片的产生率大大降低。

![](https://raw.githubusercontent.com/CompetitiveLin/ImageHostingService/picgo/imgs/202305091408302.png)
_G1收集器内存模型_

GC Roots：JVM的标记算法是通过可达性算法寻找活跃对象，而GC Roots正是可达性算法的根节点。

哪些对象可以作为GC Roots？
- 虚拟机栈(栈帧中的本地变量表)中引用的对象
- 本地方法栈(Native 方法)中引用的对象
- 方法区中类静态属性引用的对象
- 方法区中常量引用的对象
- 所有被同步锁持有的对象

垃圾收集算法：
- 标记——清除算法：顾名思义，标记可回收的对象并清除。
- 标记——复制算法：将内存分成大小相同的两份，需要垃圾收集时，将存活的对象复制到另一份内存中，缺点：内存缩小为原来的一半。
- 标记——整理算法：标记可回收的对象，将存活的对象向一端移动，适合老年代这种垃圾回收频率不高的场景。
- 分代收集算法：在新生代和老年代不同的代用不同的垃圾收集算法。


Garbage First（G1）收集器：
- 特点：引入**分区**的思路，弱化了分代的概念，并合理利用垃圾收集各个周期的资源。
- 内存结构：堆内存被切分为多个固定大小的区域，最小为1M，最大为32M，默认2048份。
- 内存分配：每个区域被标记为E、S、O和H，分别表示Eden，Survivor，Old，Humongous。Humongous区域是为了那些存储超过50%标准region大小的对象而设计的，它用来专门存放巨型对象。如果一个H区装不下一个巨型对象，那么G1会寻找连续的H分区来存储。为了能找到连续的H区，有时候不得不启动Full GC。
- 执行特点：
  - 并行与并发：使用多个CPU核缩短Stop The World停顿时间。
  - 空间整合：从整体来看是基于“标记-整理”算法实现的收集器；从局部上来看是基于“标记-复制”算法实现的。
  - 可观测的停顿：能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在垃圾收集上的时间不得超过 N 毫秒。
  - G1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region(这也就是它的名字 Garbage-First 的由来) 。
- 步骤：
  1. 初始标记
  2. 并发标记
  3. 最终标记
  4. 筛选回收
  
![](https://raw.githubusercontent.com/CompetitiveLin/ImageHostingService/picgo/imgs/202305091525435.png)


[JVM调优](https://cloud.tencent.com/developer/beta/article/1812722)：
1. 选择合适的垃圾收集器：CPU单核，只能选择Serial；CPU多核，关注吞吐量 ，那么选择[Parallel Scavenge（标记复制） + Paralle Old（标记整理）](https://juejin.cn/post/6986571159902879751)组合；CPU多核，关注用户停顿时间，JDK版本1.6或者1.7，那么选择CMS。CPU多核，关注用户停顿时间，JDK1.8及以上，JVM可用内存6G以上，那么选择G1。
2. 调整内存大小，现象：垃圾收集频率非常频繁。
3. 设置符合预期的停顿时间，现象：程序间接性的卡顿。参数：`-XX:MaxGCPauseMillis`
4. 调整内存区域大小比率，现象：某一个区域的GC频繁，其他都正常。参数：`-XX:SurvivorRatio=6, -XX:NewRatio=4`
5. 提升老年代年龄标准，现象：老年代频繁GC，每次回收的对象很多。参数：`-XX:InitialTenuringThreshol=7`
6. 调整大对象的标准，现象：老年代频繁GC，每次回收的对象很多，而且单个对象的体积都比较大。参数：`-XX:PretenureSizeThreshold=1000000//新生代可容纳的最大对象,大于则直接会分配到老年代，0代表没有限制。`
7. 调整GC的触发时机，现象：CMS收集器的情况下，G1 经常 Full GC，程序卡顿严重。
8. 调整JVM本地内存（直接内存）大小，现象：堆内存空间充足，但是报OOM

调优的一条经验总结：
>将新对象预留在新生代，由于 Full GC 的成本远高于 Minor GC，因此尽可能将对象分配在新生代是明智的做法，实际项目中根据 GC 日志分析新生代空间大小分配是否合理，适当通过“-Xmn”命令调节新生代大小，最大限度降低新对象直接进入老年代的情况。



接口和抽象类的区别：

- 相同点：
  - 都不能被实例化
  - 接口的实现类或抽象类的子类都只有实现了接口或抽象类中的方法后才能实例化

- 不同点：
  - 接口只有定义，不能有方法的实现，java 1.8中可以定义default方法体，而抽象类可以有定义与实现，方法可在抽象类中实现。
  - 实现接口的关键字为implements，继承抽象类的关键字为extends。一个类可以实现多个接口，但一个类只能继承一个抽象类。所以，使用接口可以间接地实现多重继承。
  - 接口强调特定功能的实现，而抽象类强调所属关系。
  - 接口成员变量默认为public static final，必须赋初值，不能被修改；其所有的成员方法都是public、abstract的。抽象类中成员变量默认default，可在子类中被重新定义，也可被重新赋值；抽象方法被abstract修饰，不能被private、static、synchronized和native等修饰，必须以分号结尾，不带花括号。


## static修饰词

静态常量/静态变量/静态方法是用static修饰的常量/变量/方法，其**从属于类**。另外，static是不允许用来修饰局部变量的。

- 静态方法可以调用静态变量，但不能调用非静态变量，因为静态方法在类加载时就分配了内存，而非静态变量是在对象实例化时才分配内存。

- 非静态方法可以调用静态变量，也可以调用非静态变量。

### 静态初始化块、初始化块和构造方法的区别

执行顺序：静态初始化块 > 初始化块 > 构造方法

**非静态初始化块（构造代码块）：**

作用：给对象进行初始化。对象一建立就运行，且优先于构造函数的运行。

*与构造函数的区别：*

非静态初始化块给所有对象进行统一初始化，构造函数只给对应对象初始化。

应用：将所有构造函数共性的东西定义在构造代码块中。

**静态初始化块：**

作用：给类进行初始化。随着类的加载而执行，且只执行一次

*与构造代码块的区别：*

- 构造代码块用于初始化对象，每创建一个对象就会被执行一次；静态代码块用于初始化类，随着类的加载而执行，不管创建几个对象，都只执行一次。
- 静态代码块优先于构造代码块的执行
- 都定义在类中，一个带static关键字，一个不带static



# K8s

Kubernetes主要由以下几个核心组件组成：

- etcd保存了整个集群的状态；
- apiserver提供了资源操作的唯一入口，并提供认证、授权、访问控制、API注册和发现等机制；
- controller manager负责维护集群的状态，比如故障检测、自动扩展、滚动更新等；
- scheduler负责资源的调度，按照预定的调度策略将Pod调度到相应的机器上；
- kubelet负责维持容器的生命周期，同时也负责Volume（CVI）和网络（CNI）的管理；
- Container runtime负责镜像管理以及Pod和容器的真正运行（CRI）；
- kube-proxy负责为Service提供cluster内部的服务发现和负载均衡；

除了核心组件，还有一些推荐的add-ons（扩展）：

- kube-dns负责为整个集群提供DNS服务
- Ingress Controller为服务提供外网入口
- Heapster提供资源监控
- Dashboard提供GUI
- Federation提供跨可用区的集群
- Fluentd-elasticsearch提供集群日志采集、存储与查询