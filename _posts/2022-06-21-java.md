---
title: Basics of Java
categories: [Backend, Java]
tags: [java, backend]
date: 2022-06-21T14:23:14+800
last_modified_at: 2023-05-07T23:54:58+800
pin: true
---

# 基本知识

语法糖：switch支持String、泛型、自动拆装箱、变长参数、枚举、内部类、条件编译、断言、数值下划线、for-each、try-with-resources、Lambda表达式

装箱：`Integer i = Integer.valueOf(10)`， 拆箱：`int n = i.intValue()`

类的生命周期：
- 加载：通过类的全限定名（包名 + 类名）获取class文件的二进制字节流（通过类加载器来完成，其加载过程使用[**双亲委派模型**](https://www.51cto.com/article/647617.html)），将其转化为方法区运行时的数据结构，最后在堆中实例化一个java.lang.Class对象，作为方法区中这个类的信息的入口。
- 连接
  - 验证：验证字节流包含的信息是否符合当前虚拟机的要求。
  - 准备：为类的**静态变量**分配内存并设为jvm的**默认值**（不同于下文的初值，基本类型为零，引用类型为null，final修饰的常量为设定的值），对于非静态的变量，则不会为它们分配内存。
  - 解析：虚拟机将常量池中的符号引用替换为直接引用，主要针对类或接口，字段，类方法，方法类型等。举例：通过身份证号（符号引用）查找地址（直接引用），使用内存地址（直接引用）指向方法名（符号引用）代替方法名。
- 初始化：按照顺序自上而下运行类中的变量赋值语句和静态语句，如果有父类，则首先按照顺序运行父类中的变量赋值语句和静态语句在类的初始化阶段，只会初始化与类相关的静态赋值语句和静态语句。类变量（静态变量）在方法区分配内存，并设置**初值**。
- 使用：包括主动引用和被动引用。
- 卸载：需要同时满足以下三个条件：该类所有的实例都已经被回收，即Java堆中不存在该类的任何实例；加载该类的ClassLoader已经被回收；该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。[单例对象不会被JVM垃圾回收](https://blog.csdn.net/zhengzhb/article/details/7331354)，因为无法满足卸载的第一个条件，Java堆中会始终存在该单例的实例。

线程上下文类加载器：破坏了“双亲委派模型”，可以在执行线程中抛弃双亲委派加载链模式，使程序可以逆向使用类加载器，例如SPI (Service Provider Interface)。SPI**接口**中的代码经常需要加载具体的**实现类**。SPI接口是Java核心库的一部分，由**启动类加载器(Bootstrap Classloader)**来加载，而实现类由**系统类加载器(AppClassLoader)**来加载。

![](https://raw.githubusercontent.com/CompetitiveLin/ImageHostingService/picgo/imgs/202305071548284.png)

Tomcat中的类加载器：

- Tomcat自身所使用的类加载器，会加载jre的lib包及tomcat的lib包的类，遵循双亲委派机制。加载顺序：(1).先从缓存中加载；(2).如果没有，则从JVM的Bootstrap类加载器加载；(3).如果没有，则从父类加载器加载，加载顺序是AppClassLoader、Common、Shared。(4).如果没有，则从当前类加载器加载（按照WEB-INF/classes、WEB-INF/lib的顺序）；
- 每个Web应用程序用的，每个web应用程序都有自己专用的WebappClassLoader，优先加载/web-inf/lib下的jar中的class文件，这样就隔离了每个web应用程序的影响，不遵循双亲委派机制。加载顺序：(1).先从缓存中加载；(2).如果没有，则从JVM的Bootstrap类加载器加载；(3).如果没有，则从当前类加载器加载（按照WEB-INF/classes、WEB-INF/lib的顺序）；(4).如果没有，则从父类加载器加载，由于父类加载器采用默认的委派模式，所以加载顺序是AppClassLoader、Common、Shared。

Java的SPI：当服务的提供者提供了服务接口的一种实现之后，在jar包的META-INF/services/目录里同时创建一个以服务接口命名的文件。该文件里就是实现该服务接口的具体实现类。而当外部程序装配这个模块的时候，就能通过该jar包META-INF/services/里的配置文件找到具体的实现类名，并装载实例化，完成模块的注入。


运行时数据区域包含线程共享的方法区、堆、直接内存（非运行时数据区的一部分）和线程私有的程序计数器、虚拟机栈、本地方法栈。
- 程序计数器：与操作系统中的程序计数器类似，为了线程切换后能恢复到正确的执行位置，是唯一一个不会出现 `OutOfMemoryError` 的内存区域。
- 虚拟机栈：以帧为单位，帧由局部变量表、操作数栈、动态链接、方法返回地址组成。每一次方法调用都会有一个对应的栈帧被压入栈中，每一个方法调用结束后，都会有一个栈帧被弹出。
  - 局部变量表：主要存放了编译期可知的各种数据类型（boolean、byte、char、short、int、float、long、double）、**对象引用**（reference 类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）
  - 操作数栈：用于存放方法执行过程中产生的中间计算结果，也存放计算过程中产生的临时变量。
  - 动态链接：将常量池中指向方法的符号引用转化为其在内存地址中的直接引用。与类加载中的解析类似。
  - 方法返回地址：顾名思义。
- 本地方法栈：和虚拟机栈所发挥的作用非常相似，区别是：虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而**本地方法栈则为虚拟机使用到的 Native 方法（机器码）服务**。

- 堆：唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。

三种常量池：

- 字符串常量池：简单理解为用C++实现的固定大小的HashTable。在每个VM中只有一份，存放的是字符 串常量的 引用值 。
- 类常量池：每个java文件被编译成class文件后会有一项常量池，用于存放编译器生成的**字面量**和**符号引用**。在**编译**阶段，存放的是常量的**符号引用**。
- 运行时常量池：是在**类加载完成后**，将每个class常量池中的符号引用值转存到 运行时常量池 中，也就是说，每个class都有一个 运行时常量池 ，类在 解析阶段 ，将 符号引用 替换成 直接引用 ，与 字符串常量池 中的引用值保持一致。

1.6 -> 1.7: 字符串常量池从方法区（永久代）中移到堆中。原因： GC 回收效率太低，只有在整堆收集 (Full GC)的时候才会被执行 GC。Java 程序中通常会有大量的被创建的字符串等待回收。

1.7 -> 1.8: 将运行时数据区方法区（永久代）移动到直接内存中，字符串常量池仍然在堆中。

接口和抽象类的区别：

- 相同点：
  - 都不能被实例化
  - 接口的实现类或抽象类的子类都只有实现了接口或抽象类中的方法后才能实例化

- 不同点：
  - 接口只有定义，不能有方法的实现，java 1.8中可以定义default方法体，而抽象类可以有定义与实现，方法可在抽象类中实现。
  - 实现接口的关键字为implements，继承抽象类的关键字为extends。一个类可以实现多个接口，但一个类只能继承一个抽象类。所以，使用接口可以间接地实现多重继承。
  - 接口强调特定功能的实现，而抽象类强调所属关系。
  - 接口成员变量默认为public static final，必须赋初值，不能被修改；其所有的成员方法都是public、abstract的。抽象类中成员变量默认default，可在子类中被重新定义，也可被重新赋值；抽象方法被abstract修饰，不能被private、static、synchronized和native等修饰，必须以分号结尾，不带花括号。


## static修饰词

静态常量/静态变量/静态方法是用static修饰的常量/变量/方法，其**从属于类**。另外，static是不允许用来修饰局部变量的。

- 静态方法可以调用静态变量，但不能调用非静态变量，因为静态方法在类加载时就分配了内存，而非静态变量是在对象实例化时才分配内存。

- 非静态方法可以调用静态变量，也可以调用非静态变量。

### 静态初始化块、初始化块和构造方法的区别

执行顺序：静态初始化块 > 初始化块 > 构造方法

**非静态初始化块（构造代码块）：**

作用：给对象进行初始化。对象一建立就运行，且优先于构造函数的运行。

*与构造函数的区别：*

非静态初始化块给所有对象进行统一初始化，构造函数只给对应对象初始化。

应用：将所有构造函数共性的东西定义在构造代码块中。

**静态初始化块：**

作用：给类进行初始化。随着类的加载而执行，且只执行一次

*与构造代码块的区别：*

- 构造代码块用于初始化对象，每创建一个对象就会被执行一次；静态代码块用于初始化类，随着类的加载而执行，不管创建几个对象，都只执行一次。
- 静态代码块优先于构造代码块的执行
- 都定义在类中，一个带static关键字，一个不带static



# K8s

Kubernetes主要由以下几个核心组件组成：

- etcd保存了整个集群的状态；
- apiserver提供了资源操作的唯一入口，并提供认证、授权、访问控制、API注册和发现等机制；
- controller manager负责维护集群的状态，比如故障检测、自动扩展、滚动更新等；
- scheduler负责资源的调度，按照预定的调度策略将Pod调度到相应的机器上；
- kubelet负责维持容器的生命周期，同时也负责Volume（CVI）和网络（CNI）的管理；
- Container runtime负责镜像管理以及Pod和容器的真正运行（CRI）；
- kube-proxy负责为Service提供cluster内部的服务发现和负载均衡；

除了核心组件，还有一些推荐的add-ons（扩展）：

- kube-dns负责为整个集群提供DNS服务
- Ingress Controller为服务提供外网入口
- Heapster提供资源监控
- Dashboard提供GUI
- Federation提供跨可用区的集群
- Fluentd-elasticsearch提供集群日志采集、存储与查询